<!-- doc/src/sgml/logical-replication.sgml -->

<chapter id="logical-replication">
<!--==========================orignal english content==========================
 <title>Logical Replication</title>
____________________________________________________________________________-->
 <title>逻辑复制</title>

<!--==========================orignal english content==========================
 <para>
  Logical replication is a method of replicating data objects and their
  changes, based upon their replication identity (usually a primary key).  We
  use the term logical in contrast to physical replication, which uses exact
  block addresses and byte-by-byte replication.  PostgreSQL supports both
  mechanisms concurrently, see <xref linkend="high-availability">.  Logical
  replication allows fine-grained control over both data replication and
  security.
 </para>
____________________________________________________________________________-->
 <para>
  逻辑复制是根据复制标识（通常是主键）复制数据对象及其更改的一种方法。
  我们使用术语逻辑与物理复制相比，它使用确切的块地址和逐字节复制。
  PostgreSQL同时支持这两种机制，请参阅<xref linkend="high-availability">。
  逻辑复制允许对数据复制和安全性进行精细控制。
 </para>

<!--==========================orignal english content==========================
 <para>
  Logical replication uses a <firstterm>publish</firstterm>
  and <firstterm>subscribe</firstterm> model with one or
  more <firstterm>subscribers</firstterm> subscribing to one or more
  <firstterm>publications</firstterm> on a <firstterm>publisher</firstterm>
  node.  Subscribers pull data from the publications they subscribe to and may
  subsequently re-publish data to allow cascading replication or more complex
  configurations.
 </para>
____________________________________________________________________________-->
 <para>
  逻辑复制使用<firstterm>发布</firstterm>和<firstterm>订阅</firstterm>模型，
  其中一个或多个<firstterm>订阅者</firstterm>订阅<firstterm>发布者</firstterm>
  节点上的一个或多个<firstterm>发布</firstterm>。
  订阅者从他们订阅的发布中提取数据，
  并可能随后重新发布数据以允许级联复制或更复杂的配置。
 </para>

<!--==========================orignal english content==========================
 <para>
  Logical replication of a table typically starts with taking a snapshot
  of the data on the publisher database and copying that to the subscriber.
  Once that is done, the changes on the publisher are sent to the subscriber
  as they occur in real-time.  The subscriber applies the data in the same
  order as the publisher so that transactional consistency is guaranteed for
  publications within a single subscription.  This method of data replication
  is sometimes referred to as transactional replication.
 </para>
____________________________________________________________________________-->
 <para>
  一个表的逻辑复制通常开始于发布者数据库上的数据快照并将其复制到订阅者。
  一旦完成，发布者的变化就会实时发送给订阅者。订阅者按照与发布者相同的顺序应用数据，
  以保证单个订阅内的发布的事务一致性。这种数据复制方法有时被称为事务复制。
 </para>

<!--==========================orignal english content==========================
 <para>
  The typical use-cases for logical replication are:

  <itemizedlist>
   <listitem>
    <para>
     Sending incremental changes in a single database or a subset of a
     database to subscribers as they occur.
    </para>
   </listitem>

   <listitem>
    <para>
     Firing triggers for individual changes as they arrive on the
     subscriber.
    </para>
   </listitem>

   <listitem>
    <para>
     Consolidating multiple databases into a single one (for example for
     analytical purposes).
    </para>
   </listitem>

   <listitem>
    <para>
     Replicating between different major versions of PostgreSQL.
    </para>
   </listitem>

   <listitem>
    <para>
     Giving access to replicated data to different groups of users.
    </para>
   </listitem>

   <listitem>
    <para>
     Sharing a subset of the database between multiple databases.
    </para>
   </listitem>
  </itemizedlist>
 </para>
____________________________________________________________________________-->
 <para>
  典型的逻辑复制用例有：

  <itemizedlist>
   <listitem>
    <para>
     在单个数据库或数据库的子集中发送增量更改到订阅者。
    </para>
   </listitem>

   <listitem>
    <para>
     在更改到达订阅者时为单个更改触发触发器。
    </para>
   </listitem>

   <listitem>
    <para>
     将多个数据库合并成一个数据库（例如出于分析目的）。
    </para>
   </listitem>

   <listitem>
    <para>
     在PostgreSQL的不同主要版本之间复制。
    </para>
   </listitem>

   <listitem>
    <para>
     为不同的用户组提供对复制数据的访问。
    </para>
   </listitem>

   <listitem>
    <para>
     在多个数据库之间共享数据库的一个子集。
    </para>
   </listitem>
  </itemizedlist>
 </para>

<!--==========================orignal english content==========================
 <para>
  The subscriber database behaves in the same way as any other PostgreSQL
  instance and can be used as a publisher for other databases by defining its
  own publications.  When the subscriber is treated as read-only by
  application, there will be no conflicts from a single subscription.  On the
  other hand, if there are other writes done either by an application or by other
  subscribers to the same set of tables, conflicts can arise.
 </para>
____________________________________________________________________________-->
 <para>
  订阅者数据库的行为与任何其他PostgreSQ实例的行为相同，
  可以通过定义其自己的发布来用作其他数据库的发布者。
  当订阅者被应用程序视为只读时，将不会有单个订阅的冲突。
  但是，如果应用程序或其他订阅者对同一组表执行其他写操作，则可能会产生冲突。
 </para>

 <sect1 id="logical-replication-publication">
<!--==========================orignal english content==========================
  <title>Publication</title>
____________________________________________________________________________-->
  <title>发布</title>

<!--==========================orignal english content==========================
  <para>
   A <firstterm>publication</firstterm> can be defined on any physical
   replication master.  The node where a publication is defined is referred to
   as <firstterm>publisher</firstterm>.  A publication is a set of changes
   generated from a table or a group of tables, and might also be described as
   a change set or replication set.  Each publication exists in only one database.
  </para>
____________________________________________________________________________-->
  <para>
   可以在任何物理复制主机上定义<firstterm>发布</firstterm>。
   定义发布的节点称为<firstterm>发布者</firstterm>。
   发布是从一个表或一组表中生成的一组更改，也可能被描述为更改集或复制集。
   每个发布只存在于一个数据库中。
  </para>

<!--==========================orignal english content==========================
  <para>
   Publications are different from schemas and do not affect how the table is
   accessed.  Each table can be added to multiple publications if needed.
   Publications may currently only contain tables.  Objects must be added
   explicitly, except when a publication is created for <literal>ALL
   TABLES</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   发布与模式不同，不影响表格的访问方式。如果需要，每张表可以添加到多个发布。
   发布目前可能只包含表。对象必须显式添加，
   除非为<literal>ALL TABLES</literal>创建了一个发布。
  </para>

<!--==========================orignal english content==========================
  <para>
   Publications can choose to limit the changes they produce to
   any combination of <command>INSERT</command>, <command>UPDATE</command>, and
   <command>DELETE</command>, similar to how triggers are fired by
   particular event types.  By default, all operation types are replicated.
  </para>
____________________________________________________________________________-->
  <para>
   发布可以选择将它们所产生的改变限制在<command>INSERT</command>，
   <command>UPDATE</command>和<command>DELETE</command>的任意组合上，
   类似于触发器被特定事件类型触发。默认情况下，复制所有操作类型。
  </para>

<!--==========================orignal english content==========================
  <para>
   A published table must have a <quote>replica identity</quote> configured in
   order to be able to replicate <command>UPDATE</command>
   and <command>DELETE</command> operations, so that appropriate rows to
   update or delete can be identified on the subscriber side.  By default,
   this is the primary key, if there is one.  Another unique index (with
   certain additional requirements) can also be set to be the replica
   identity.  If the table does not have any suitable key, then it can be set
   to replica identity <quote>full</quote>, which means the entire row becomes
   the key.  This, however, is very inefficient and should only be used as a
   fallback if no other solution is possible.  If a replica identity other
   than <quote>full</quote> is set on the publisher side, a replica identity
   comprising the same or fewer columns must also be set on the subscriber
   side.  See <xref linkend="SQL-CREATETABLE-REPLICA-IDENTITY"> for details on
   how to set the replica identity.  If a table without a replica identity is
   added to a publication that replicates <command>UPDATE</command>
   or <command>DELETE</command> operations then
   subsequent <command>UPDATE</command> or <command>DELETE</command>
   operations will cause an error on the publisher.  <command>INSERT</command>
   operations can proceed regardless of any replica identity.
  </para>
____________________________________________________________________________-->
  <para>
   已发布的表格必须配置一个<quote>副本标识</quote>以便能够复制
   <command>UPDATE</command>和<command>DELETE</command>操作，
   这样可以在订阅者端识别适当的行来更新或删除。默认情况下，这是主键，
   如果有的话。另外唯一的索引（有一些额外的要求）也可以被设置为副本标识。
   如果表没有任何合适的键，那么它可以设置为复制标识<quote>full</quote>，
   这意味着整个行成为键。但是，这是非常低效的，
   并且只能在没有其他可能的解决方案时用作后备。
   如果发布者端设置了除<quote>full</quote>之外的副本标识，
   则还必须在订阅者端设置包含相同或更少列的副本标识。
   有关如何设置副本标识的详细信息，请参见<xref linkend="SQL-CREATETABLE-REPLICA-IDENTITY">。
   如果没有副本标识的表被添加到复制<command>UPDATE</command>或<command>DELETE</command>
   操作的发布中，则后续的<command>UPDATE</command>或<command>DELETE</command>
   操作会在发布者上造成错误。无视副本标识，<command>INSERT</command>操作都可以进行。
  </para>

<!--==========================orignal english content==========================
  <para>
   Every publication can have multiple subscribers.
  </para>
____________________________________________________________________________-->
  <para>
   每个发布可以有多个订阅者。
  </para>

<!--==========================orignal english content==========================
  <para>
   A publication is created using the <xref linkend="sql-createpublication">
   command and may later be altered or dropped using corresponding commands.
  </para>
____________________________________________________________________________-->
  <para>
   使用<xref linkend="sql-createpublication">命令创建发布，稍后可以使用对应的命令修改或删除。
  </para>

<!--==========================orignal english content==========================
  <para>
   The individual tables can be added and removed dynamically using
   <xref linkend="sql-alterpublication">.  Both the <literal>ADD
   TABLE</literal> and <literal>DROP TABLE</literal> operations are
   transactional; so the table will start or stop replicating at the correct
   snapshot once the transaction has committed.
  </para>
____________________________________________________________________________-->
  <para>
   使用<xref linkend="sql-alterpublication">可以动态的添加或删除单个表。
   <literal>ADD TABLE</literal>和<literal>DROP TABLE</literal>操作都是事务型的；
   所以一旦事务提交，表就会启动或停止在正确的快照上复制。
  </para>
 </sect1>

 <sect1 id="logical-replication-subscription">
<!--==========================orignal english content==========================
  <title>Subscription</title>
____________________________________________________________________________-->
  <title>订阅</title>

<!--==========================orignal english content==========================
  <para>
   A <firstterm>subscription</firstterm> is the downstream side of logical
   replication.  The node where a subscription is defined is referred to as
   the <firstterm>subscriber</firstterm>.  A subscription defines the connection
   to another database and set of publications (one or more) to which it wants
   to subscribe.
  </para>
____________________________________________________________________________-->
  <para>
   <firstterm>订阅</firstterm>是逻辑复制的下游端。定义订阅的节点被称为
   <firstterm>订阅者</firstterm>。
   订阅定义了与另一个数据库的连接以及它想要订阅的一组发布（一个或多个）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The subscriber database behaves in the same way as any other PostgreSQL
   instance and can be used as a publisher for other databases by defining its
   own publications.
  </para>
____________________________________________________________________________-->
  <para>
   订阅者数据库的行为与任何其他PostgreSQL实例的行为相同，
   并且可以通过定义自己的发布来用作其他数据库的发布者。
  </para>

<!--==========================orignal english content==========================
  <para>
   A subscriber node may have multiple subscriptions if desired.  It is
   possible to define multiple subscriptions between a single
   publisher-subscriber pair, in which case care must be taken to ensure
   that the subscribed publication objects don't overlap.
  </para>
____________________________________________________________________________-->
  <para>
   如果需要，一个订阅者节点可以有多个订阅。在单个发布者-订阅者对之间可以定义多个订阅，
   这种情况下，必须小心确保订阅的发布对象不重复。
  </para>

<!--==========================orignal english content==========================
  <para>
   Each subscription will receive changes via one replication slot (see
   <xref linkend="streaming-replication-slots">).  Additional temporary
   replication slots may be required for the initial data synchronization
   of pre-existing table data.
  </para>
____________________________________________________________________________-->
  <para>
   每个订阅都将通过一个复制槽接收更改（请参阅<xref linkend="streaming-replication-slots">）。
   对于预先存在的表数据的初始数据同步可能需要额外的临时复制槽。
  </para>

<!--==========================orignal english content==========================
  <para>
   A logical replication subscription can be a standby for synchronous
   replication (see <xref linkend="synchronous-replication">).  The standby
   name is by default the subscription name.  An alternative name can be
   specified as <literal>application_name</literal> in the connection
   information of the subscription.
  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制订阅可以作为同步复制的备用数据库（请参见<xref linkend="synchronous-replication">）。
   备用名称默认是订阅名称。可以在订阅的连接信息中指定一个替代名称为
   <literal>application_name </literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Subscriptions are dumped by <command>pg_dump</command> if the current user
   is a superuser.  Otherwise a warning is written and subscriptions are
   skipped, because non-superusers cannot read all subscription information
   from the <structname>pg_subscription</structname> catalog.
  </para>
____________________________________________________________________________-->
  <para>
   如果当前用户是超级用户，则通过<command>pg_dump</command>转储订阅。
   否则会发出警告，并且会跳过订阅，因为非超级用户无法读取
   <structname>pg_subscription</structname>目录中的所有订阅信息。
  </para>

<!--==========================orignal english content==========================
  <para>
   The subscription is added using <xref linkend="sql-createsubscription"> and
   can be stopped/resumed at any time using the
   <xref linkend="sql-altersubscription"> command and removed using
   <xref linkend="sql-dropsubscription">.
  </para>
____________________________________________________________________________-->
  <para>
   订阅是使用<xref linkend="sql-createsubscription">添加的，
   并且可以随时使用<xref linkend="sql-altersubscription">命令停止/恢复，
   使用<xref linkend="sql-dropsubscription">删除。
  </para>

<!--==========================orignal english content==========================
  <para>
   When a subscription is dropped and recreated, the synchronization
   information is lost.  This means that the data has to be resynchronized
   afterwards.
  </para>
____________________________________________________________________________-->
  <para>
   当订阅被删除并重新创建时，同步信息将丢失。这意味着之后的数据必须重新同步。
  </para>

<!--==========================orignal english content==========================
  <para>
   The schema definitions are not replicated, and the published tables must
   exist on the subscriber.  Only regular tables may be
   the target of replication.  For example, you can't replicate to a view.
  </para>
____________________________________________________________________________-->
  <para>
   架构定义不会被复制，并且已发布的表格必须存在于订阅者上。
   只有常规表可以是复制的目标。例如，您不能复制到视图。
  </para>

<!--==========================orignal english content==========================
  <para>
   The tables are matched between the publisher and the subscriber using the
   fully qualified table name.  Replication to differently-named tables on the
   subscriber is not supported.
  </para>
____________________________________________________________________________-->
  <para>
   发布者和订阅者之间的表使用完全限定的表名匹配。不支持复制到订阅者上不同名称的表。
  </para>

<!--==========================orignal english content==========================
  <para>
   Columns of a table are also matched by name.  A different order of columns
   in the target table is allowed, but the column types have to match.  The
   target table can have additional columns not provided by the published
   table.  Those will be filled with their default values.
  </para>
____________________________________________________________________________-->
  <para>
   一个表的列也是按名字匹配的。目标表中不同的列顺序是允许的，
   但是列类型必须匹配。目标表可以有发布的表未提供的附加列。
   那些将被填充他们的默认值。
  </para>

  <sect2 id="logical-replication-subscription-slot">
<!--==========================orignal english content==========================
   <title>Replication Slot Management</title>
____________________________________________________________________________-->
   <title>复制槽管理</title>

<!--==========================orignal english content==========================
   <para>
    As mentioned earlier, each (active) subscription receives changes from a
    replication slot on the remote (publishing) side.  Normally, the remote
    replication slot is created automatically when the subscription is created
    using <command>CREATE SUBSCRIPTION</command> and it is dropped
    automatically when the subscription is dropped using <command>DROP
    SUBSCRIPTION</command>.  In some situations, however, it can be useful or
    necessary to manipulate the subscription and the underlying replication
    slot separately.  Here are some scenarios:

    <itemizedlist>
     <listitem>
      <para>
       When creating a subscription, the replication slot already exists.  In
       that case, the subscription can be created using
       the <literal>create_slot = false</literal> option to associate with the
       existing slot.
      </para>
     </listitem>

     <listitem>
      <para>
       When creating a subscription, the remote host is not reachable or in an
       unclear state.  In that case, the subscription can be created using
       the <literal>connect = false</literal> option.  The remote host will then not
       be contacted at all.  This is what <application>pg_dump</application>
       uses.  The remote replication slot will then have to be created
       manually before the subscription can be activated.
      </para>
     </listitem>

     <listitem>
      <para>
       When dropping a subscription, the replication slot should be kept.
       This could be useful when the subscriber database is being moved to a
       different host and will be activated from there.  In that case,
       disassociate the slot from the subscription using <command>ALTER
       SUBSCRIPTION</command> before attempting to drop the subscription.
      </para>
     </listitem>

     <listitem>
      <para>
       When dropping a subscription, the remote host is not reachable.  In
       that case, disassociate the slot from the subscription
       using <command>ALTER SUBSCRIPTION</command> before attempting to drop
       the subscription.  If the remote database instance no longer exists, no
       further action is then necessary.  If, however, the remote database
       instance is just unreachable, the replication slot should then be
       dropped manually; otherwise it would continue to reserve WAL and might
       eventually cause the disk to fill up.  Such cases should be carefully
       investigated.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    如前所述，每个（活动）订阅都从远程（发布）端的复制槽接收更改。
	通常，使用<command>CREATE SUBSCRIPTION</command>
	创建订阅时会自动创建远程复制槽，使用<command>DROP SUBSCRIPTION</command>
	删除订阅时会自动删除该槽。但是，在某些情况下，
	单独操作订阅和底层复制槽是有用的或必要的。以下是一些情况：

    <itemizedlist>
     <listitem>
      <para>
       创建订阅时，复制槽已经存在。在这种情况下，
	   订阅可以使用<literal>create_slot = false</literal>选项与现有槽关联来创建。
      </para>
     </listitem>

     <listitem>
      <para>
       创建订阅时，远程主机无法访问或处于不清晰的状态。在这种情况下，
	   可以使用<literal>connect = false</literal>选项创建订阅。
	   这样将不连接远程主机。这是<application>pg_dump</application>使用的内容。
	   远程复制槽必须在订阅激活之前手动创建。
      </para>
     </listitem>

     <listitem>
      <para>
       在删除订阅时，应该保留复制槽。在订阅者的数据库被移动到不同的主机，
	   并在那里激活时，这可能是有用的。在这种情况下，尝试删除订阅之前，
	   使用<command>ALTER SUBSCRIPTION</command>解除槽与订阅的关联。
      </para>
     </listitem>

     <listitem>
      <para>
       在删除订阅时，远程主机不可访问。在这种情况下，尝试删除订阅之前，
	   使用<command>ALTER SUBSCRIPTION</command>解除槽与订阅的关联。
	   如果远程数据库实例不再存在，则不需要进一步的操作。但是，
	   如果远程数据库实例只是不可访问，则应手动删除复制槽；
	   否则会继续保留WAL，最终可能导致磁盘空间不足。这种情况应该仔细调查。
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-conflicts">
<!--==========================orignal english content==========================
  <title>Conflicts</title>
____________________________________________________________________________-->
  <title>冲突</title>

<!--==========================orignal english content==========================
  <para>
   Logical replication behaves similarly to normal DML operations in that
   the data will be updated even if it was changed locally on the subscriber
   node.  If incoming data violates any constraints the replication will
   stop.  This is referred to as a <firstterm>conflict</firstterm>.  When
   replicating <command>UPDATE</command> or <command>DELETE</command>
   operations, missing data will not produce a conflict and such operations
   will simply be skipped.
  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制的行为与普通的DML操作类似，因为即使订阅者节点本地更改了数据，
   数据也将被更新。如果传入数据违反任何限制，复制将停止。
   这被称为<firstterm>冲突</firstterm>。当复制<command>UPDATE</command>
   或者<command>DELETE</command>操作时，丢失的数据不会产生冲突，这样的操作将被忽略。
  </para>

<!--==========================orignal english content==========================
  <para>
   A conflict will produce an error and will stop the replication; it must be
   resolved manually by the user.  Details about the conflict can be found in
   the subscriber's server log.
  </para>
____________________________________________________________________________-->
  <para>
   冲突会产生错误，并会停止复制；它必须由用户手动解决。
   有关冲突的详细信息可以在订阅者的服务器日志中找到。
  </para>

<!--==========================orignal english content==========================
  <para>
   The resolution can be done either by changing data on the subscriber so
   that it does not conflict with the incoming change or by skipping the
   transaction that conflicts with the existing data.  The transaction can be
   skipped by calling the <link linkend="pg-replication-origin-advance">
   <function>pg_replication_origin_advance()</function></link> function with
   a <parameter>node_name</parameter> corresponding to the subscription name,
   and a position.  The current position of origins can be seen in the
   <link linkend="view-pg-replication-origin-status">
   <structname>pg_replication_origin_status</structname></link> system view.
  </para>
____________________________________________________________________________-->
  <para>
   解决方案可以通过更改订阅者上的数据来完成，以免它与传入的更改冲突，
   或者跳过与现有数据冲突的事务。事务可以通过调用
   <link linkend="pg-replication-origin-advance"><function>pg_replication_origin_advance()</function></link>
   函数使用<parameter>node_name</parameter>对应订阅名称和位置来跳过。
   源的当前位置可以在<link linkend="view-pg-replication-origin-status">
   <structname>pg_replication_origin_status</structname></link>
   系统视图中看到。
  </para>
 </sect1>

 <sect1 id="logical-replication-restrictions">
<!--==========================orignal english content==========================
  <title>Restrictions</title>
____________________________________________________________________________-->
  <title>限制</title>

<!--==========================orignal english content==========================
  <para>
   Logical replication currently has the following restrictions or missing
   functionality.  These might be addressed in future releases.
  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制目前有以下限制或缺少的功能。 这些可能会在未来的版本中解决。
  </para>

  <itemizedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     The database schema and DDL commands are not replicated.  The initial
     schema can be copied by hand using <literal>pg_dump
     -&minus;schema-only</literal>.  Subsequent schema changes would need to be kept
     in sync manually.  (Note, however, that there is no need for the schemas
     to be absolutely the same on both sides.)  Logical replication is robust
     when schema definitions change in a live database: When the schema is
     changed on the publisher and replicated data starts arriving at the
     subscriber but does not fit into the table schema, replication will error
     until the schema is updated.  In many cases, intermittent errors can be
     avoided by applying additive schema changes to the subscriber first.
    </para>
____________________________________________________________________________-->
    <para>
     不复制数据库模式和DDL命令。初始模式可以使用<literal>pg_dump --schema-only</literal>
	 手动复制。后续的模式更改需要手动保持同步。（但是请注意，
	 两端的架构不需要完全相同。）当实时数据库中的模式定义更改时，逻辑复制是健壮的：
	 当模式在发布者上发生更改并且复制的数据开始到达订阅者但不符合表模式，
	 复制将错误，直到模式更新。在很多情况下，
	 间歇性错误可以通过首先将附加模式更改应用于订阅者来避免。
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     Sequence data is not replicated.  The data in serial or identity columns
     backed by sequences will of course be replicated as part of the table,
     but the sequence itself would still show the start value on the
     subscriber.  If the subscriber is used as a read-only database, then this
     should typically not be a problem.  If, however, some kind of switchover
     or failover to the subscriber database is intended, then the sequences
     would need to be updated to the latest values, either by copying the
     current data from the publisher (perhaps
     using <command>pg_dump</command>) or by determining a sufficiently high
     value from the tables themselves.
    </para>
____________________________________________________________________________-->
    <para>
     不复制序列数据。序列支持的序列或标识列中的数据当然会作为表的一部分被复制，
	 但序列本身仍然会显示订阅者的起始值。如果订阅者被用作只读数据库，
	 那么这通常不成问题。但是，如果打算对订阅者数据库进行某种切换或故障切换，
	 则需要将序列更新为最新值，方法是从发布者复制当前数据
	 （可能使用<command>pg_dump</command>）或者从表中确定足够高的值。
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     <command>TRUNCATE</command> commands are not replicated.  This can, of
     course, be worked around by using <command>DELETE</command> instead.  To
     avoid accidental <command>TRUNCATE</command> invocations, you can revoke
     the <literal>TRUNCATE</literal> privilege from tables.
    </para>
____________________________________________________________________________-->
    <para>
     不复制<command>TRUNCATE</command>命令。当然，可以通过使用<command>DELETE</command>
	 来解决。为了避免意外的<command>TRUNCATE</command>调用，可以撤销表的
	 <literal>TRUNCATE</literal>权限。
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     Large objects (see <xref linkend="largeobjects">) are not replicated.
     There is no workaround for that, other than storing data in normal
     tables.
    </para>
____________________________________________________________________________-->
    <para>
     不复制大对象（参阅<xref linkend="largeobjects">）。
	 没有什么解决办法，除非在普通表中存储数据。
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     Replication is only possible from base tables to base tables.  That is,
     the tables on the publication and on the subscription side must be normal
     tables, not views, materialized views, partition root tables, or foreign
     tables.  In the case of partitions, you can therefore replicate a
     partition hierarchy one-to-one, but you cannot currently replicate to a
     differently partitioned setup.  Attempts to replicate tables other than
     base tables will result in an error.
    </para>
____________________________________________________________________________-->
    <para>
     复制只能从基表到基表。也就是说，发布和订阅端的表必须是普通表，而不是视图，
	 物化视图，分区根表或外部表。对于分区，您可以一对一地复制分区层次结构，
	 但目前不能复制到不同的分区设置。尝试复制基表以外的表将导致错误。
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="logical-replication-architecture">
<!--==========================orignal english content==========================
  <title>Architecture</title>
____________________________________________________________________________-->
  <title>架构</title>

<!--==========================orignal english content==========================
  <para>
   Logical replication starts by copying a snapshot of the data on the
   publisher database.  Once that is done, changes on the publisher are sent
   to the subscriber as they occur in real time.  The subscriber applies data
   in the order in which commits were made on the publisher so that
   transactional consistency is guaranteed for the publications within any
   single subscription.
  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制首先复制发布者数据库上的数据快照。一旦完成，
   发布者的变化就会实时发送给订阅者。订阅者按照发布者提交的顺序应用数据，
   以确保任何单个订阅中的发布的事务一致性。
  </para>

<!--==========================orignal english content==========================
  <para>
   Logical replication is built with an architecture similar to physical
   streaming replication (see <xref linkend="streaming-replication">).  It is
   implemented by <quote>walsender</quote> and <quote>apply</quote>
   processes.  The walsender process starts logical decoding (described
   in <xref linkend="logicaldecoding">) of the WAL and loads the standard
   logical decoding plugin (pgoutput).  The plugin transforms the changes read
   from WAL to the logical replication protocol
   (see <xref linkend="protocol-logical-replication">) and filters the data
   according to the publication specification.  The data is then continuously
   transferred using the streaming replication protocol to the apply worker,
   which maps the data to local tables and applies the individual changes as
   they are received, in correct transactional order.
  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制采用类似于物理流式复制的体系结构（请参见
   <xref linkend="streaming-replication">）。它是通过<quote>walsender</quote>
   和<quote>apply</quote>进程实现的。walsender进程启动WAL的逻辑解码
   （在<xref linkend="logicaldecoding">中描述），并加载标准的逻辑解码插件
   （pgoutput）。该插件将从WAL读取的更改转换为逻辑复制协议
   （请参阅<xref linkend="protocol-logical-replication">），
   并根据发布规范过滤数据。然后使用流式复制协议将数据连续传输到应用工作人员，
   应用工作人员将数据映射到本地表，并按照正确的事务顺序应用接收到的各个更改。
  </para>

<!--==========================orignal english content==========================
  <para>
   The apply process on the subscriber database always runs with
   <varname>session_replication_role</varname> set
   to <literal>replica</literal>, which produces the usual effects on triggers
   and constraints.
  </para>
____________________________________________________________________________-->
  <para>
   订阅者数据库上的应用程序始终以<varname>session_replication_role</varname>
   设置为<literal>replica</literal>运行，这会对触发器和约束产生通常的影响。
  </para>

<!--==========================orignal english content==========================
  <para>
   The logical replication apply process currently only fires row triggers,
   not statement triggers.  The initial table synchronization, however, is
   implemented like a <command>COPY</command> command and thus fires both row
   and statement triggers for <command>INSERT</command>.
  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制应用程序目前仅触发行触发器，不触发语句触发器。不过，
   初始表同步像<command>COPY</command>命令一样执行，
   因此触发了<command>INSERT</command>的行和语句触发器。
  </para>

  <sect2 id="logical-replication-snapshot">
<!--==========================orignal english content==========================
    <title>Initial Snapshot</title>
____________________________________________________________________________-->
    <title>初始快照</title>
<!--==========================orignal english content==========================
    <para>
      The initial data in existing subscribed tables are snapshotted and
      copied in a parallel instance of a special kind of apply process.
      This process will create its own temporary replication slot and
      copy the existing data. Once existing data is copied, the worker
      enters synchronization mode, which ensures that the table is brought
      up to a synchronized state with the main apply process by streaming
      any changes that happened during the initial data copy using standard
      logical replication. Once the synchronization is done, the control
      of the replication of the table is given back to the main apply
      process where the replication continues as normal.
    </para>
____________________________________________________________________________-->
    <para>
      给现有订阅表中的初始数据做快照，并复制到特殊类型的应用程序的并行实例中。
	  此过程将创建自己的临时复制槽并复制现有数据。一旦现有数据复制完成，
	  工作人员进入同步模式，通过使用标准逻辑复制，
	  流式传输在初始数据复制过程中发生的任何变化，
	  确保表与主应用程序进入同步状态。一旦完成同步，
	  表的复制的控制权返回到复制继续正常进行的主应用进程。
    </para>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-monitoring">
<!--==========================orignal english content==========================
  <title>Monitoring</title>
____________________________________________________________________________-->
  <title>监控</title>

<!--==========================orignal english content==========================
  <para>
   Because logical replication is based on a similar architecture as
   <link linkend="streaming-replication">physical streaming replication</link>,
   the monitoring on a publication node is similar to monitoring of a
   physical replication master
   (see <xref linkend="streaming-replication-monitoring">).
  </para>
____________________________________________________________________________-->
  <para>
   由于逻辑复制基于与<link linkend="streaming-replication">物理流式复制</link>
   类似的体系结构，因此发布节点上的监视与物理复制主节点的监视类似
   （请参见<xref linkend="streaming-replication-monitoring">）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The monitoring information about subscription is visible in
   <link linkend="pg-stat-subscription"><literal>pg_stat_subscription</literal></link>.
   This view contains one row for every subscription worker.  A subscription
   can have zero or more active subscription workers depending on its state.
  </para>
____________________________________________________________________________-->
  <para>
   有关订阅的监控信息可以在<link linkend="pg-stat-subscription"><literal>pg_stat_subscription</literal></link>
   中看到。该视图对于每个订阅工作者都包含一行。根据订阅的状态，
   订阅可以有零个或多个活动的订阅工作者。
  </para>

<!--==========================orignal english content==========================
  <para>
   Normally, there is a single apply process running for an enabled
   subscription.  A disabled subscription or a crashed subscription will have
   zero rows in this view.  If the initial data synchronization of any
   table is in progress, there will be additional workers for the tables
   being synchronized.
  </para>
____________________________________________________________________________-->
  <para>
   通常情况下，为启用的订阅运行一个应用程序。此视图中禁用的订阅或崩溃的订阅将有零行。
   如果任何表的初始数据同步正在进行，则会有额外的工作人员同步表。
  </para>
 </sect1>

 <sect1 id="logical-replication-security">
<!--==========================orignal english content==========================
  <title>Security</title>
____________________________________________________________________________-->
  <title>安全</title>

<!--==========================orignal english content==========================
  <para>
   The role used for the replication connection must have
   the <literal>REPLICATION</literal> attribute (or be a superuser).  Access for the role must be
   configured in <filename>pg_hba.conf</filename>.
  </para>
____________________________________________________________________________-->
  <para>
   用于复制链接的角色必须具有<literal>REPLICATION</literal>属性
   （或者是超级用户）。该用户的访问权限必须在<filename>pg_hba.conf</filename>中配置。
  </para>

<!--==========================orignal english content==========================
  <para>
   To create a publication, the user must have the <literal>CREATE</literal>
   privilege in the database.
  </para>
____________________________________________________________________________-->
  <para>
   用户必须具有数据库的<literal>CREATE</literal>权限才能创建发布。
  </para>

<!--==========================orignal english content==========================
  <para>
   To add tables to a publication, the user must have ownership rights on the
   table.  To create a publication that publishes all tables automatically,
   the user must be a superuser.
  </para>
____________________________________________________________________________-->
  <para>
   用户必须具有表的所有权才能将该表添加到一个发布。
   只有超级用户才能创建一个自动发布所有表的发布。
  </para>

<!--==========================orignal english content==========================
  <para>
   To create a subscription, the user must be a superuser.
  </para>
____________________________________________________________________________-->
  <para>
   只有超级用户才能创建一个订阅。
  </para>

<!--==========================orignal english content==========================
  <para>
   The subscription apply process will run in the local database with the
   privileges of a superuser.
  </para>
____________________________________________________________________________-->
  <para>
   订阅应用程序将以超级用户的权限在本地数据库中运行。
  </para>

<!--==========================orignal english content==========================
  <para>
   Privileges are only checked once at the start of a replication connection.
   They are not re-checked as each change record is read from the publisher,
   nor are they re-checked for each change when applied.
  </para>
____________________________________________________________________________-->
  <para>
   只在复制连接开始时检查一次权限。当从发布者读取每个更改记录时，
   不重新检查权限，也不会在应用每个更改时重新检查权限。
  </para>
 </sect1>

 <sect1 id="logical-replication-config">
<!--==========================orignal english content==========================
  <title>Configuration Settings</title>
____________________________________________________________________________-->
  <title>配置设置</title>

<!--==========================orignal english content==========================
  <para>
   Logical replication requires several configuration options to be set.
  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制需要设置几个配置选项。
  </para>

<!--==========================orignal english content==========================
  <para>
   On the publisher side, <varname>wal_level</varname> must be set to
   <literal>logical</literal>, and <varname>max_replication_slots</varname>
   must be set to at least the number of subscriptions expected to connect,
   plus some reserve for table synchronization.  And
   <varname>max_wal_senders</varname> should be set to at least the same as
   <varname>max_replication_slots</varname> plus the number of physical
   replicas that are connected at the same time.
  </para>
____________________________________________________________________________-->
  <para>
   在发布者端，必须将<varname>wal_level</varname>设置为<literal>logical</literal>，
   并且<varname>max_replication_slots</varname>必须至少设置为预期连接的订阅数量，
   加上一些预留用于表同步。并且<varname>max_wal_senders</varname>
   应至少设置为与<varname>max_replication_slots</varname>相同，
   加上同时连接的物理复制的数量。
  </para>

<!--==========================orignal english content==========================
  <para>
   The subscriber also requires the <varname>max_replication_slots</varname>
   to be set.  In this case it should be set to at least the number of
   subscriptions that will be added to the subscriber.
   <varname>max_logical_replication_workers</varname> must be set to at
   least the number of subscriptions, again plus some reserve for the table
   synchronization.  Additionally the <varname>max_worker_processes</varname>
   may need to be adjusted to accommodate for replication workers, at least
   (<varname>max_logical_replication_workers</varname>
   + <literal>1</literal>).  Note that some extensions and parallel queries
   also take worker slots from <varname>max_worker_processes</varname>.
  </para>
____________________________________________________________________________-->
  <para>
   订阅者还需要设置<varname>max_replication_slots</varname>。在这种情况下，
   它应该至少设置为将被添加到订阅者的订阅数量。<varname>max_logical_replication_workers</varname>
   必须至少设置为订阅数量，再加上一些保留用于表同步。此外，
   可能需要调整<varname>max_worker_processes</varname>以适应复制工作者，
   至少（<varname>max_logical_replication_workers</varname> + <literal>1</literal>）。
   请注意，某些扩展和并行查询还需要<varname>max_worker_processes</varname>
   中的工作者插槽。
  </para>
 </sect1>

 <sect1 id="logical-replication-quick-setup">
<!--==========================orignal english content==========================
  <title>Quick Setup</title>
____________________________________________________________________________-->
  <title>快速设置</title>

<!--==========================orignal english content==========================
  <para>
   First set the configuration options in <filename>postgresql.conf</filename>:
<programlisting>
wal_level = logical
</programlisting>
   The other required settings have default values that are sufficient for a
   basic setup.
  </para>
____________________________________________________________________________-->
  <para>
   首先设置<filename>postgresql.conf</filename>中的配置选项:
<programlisting>
wal_level = logical
</programlisting>
   其他所需设置的默认值对于基本设置来说足够了。
  </para>

<!--==========================orignal english content==========================
  <para>
   <filename>pg_hba.conf</filename> needs to be adjusted to allow replication
   (the values here depend on your actual network configuration and user you
   want to use for connecting):
<programlisting>
host     all     repuser     0.0.0.0/0     md5
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   需要调整<filename>pg_hba.conf</filename>以允许复制
   （这里的值取决于你的实际网络配置和你想要用于连接的用户）：
<programlisting>
host     all     repuser     0.0.0.0/0     md5
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Then on the publisher database:
<programlisting>
CREATE PUBLICATION mypub FOR TABLE users, departments;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   然后在发布者数据库上：
<programlisting>
CREATE PUBLICATION mypub FOR TABLE users, departments;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   And on the subscriber database:
<programlisting>
CREATE SUBSCRIPTION mysub CONNECTION 'dbname=foo host=bar user=repuser' PUBLICATION mypub;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   在订阅者数据库上：
<programlisting>
CREATE SUBSCRIPTION mysub CONNECTION 'dbname=foo host=bar user=repuser' PUBLICATION mypub;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   The above will start the replication process, which synchronizes the
   initial table contents of the tables <literal>users</literal> and
   <literal>departments</literal> and then starts replicating
   incremental changes to those tables.
  </para>
____________________________________________________________________________-->
  <para>
   上面将启动复制过程，该过程同步表<literal>users</literal>和<literal>departments</literal>
   的初始表内容，然后开始将增量更改复制到这些表。
  </para>
 </sect1>
</chapter>
