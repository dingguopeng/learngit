<!-- doc/src/sgml/ref/pgbench.sgml -->

<refentry id="pgbench">
<!--==========================orignal english content==========================
 <indexterm zone="pgbench">
  <primary>pgbench</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="pgbench">
  <primary>pgbench</primary>
 </indexterm>
 
<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle><application>pgbench</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle><application>pgbench</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>pgbench</refname>
  <refpurpose>run a benchmark test on <productname>PostgreSQL</productname></refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>pgbench</refname>
  <refpurpose>在<productname>PostgreSQL</productname>上运行一个基准测试</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
  <cmdsynopsis>
   <command>pgbench</command>
   <arg choice="plain"><option>-i</option></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>dbname</replaceable></arg>
  </cmdsynopsis>
____________________________________________________________________________-->
  <cmdsynopsis>
   <command>pgbench</command>
   <arg choice="plain"><option>-i</option></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>dbname</replaceable></arg>
  </cmdsynopsis>
<!--==========================orignal english content==========================
  <cmdsynopsis>
   <command>pgbench</command>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>dbname</replaceable></arg>
  </cmdsynopsis>
____________________________________________________________________________-->
  <cmdsynopsis>
   <command>pgbench</command>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>dbname</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>
<!--==========================orignal english content==========================
 <para>
  <application>pgbench</application> is a simple program for running benchmark
  tests on <productname>PostgreSQL</>.  It runs the same sequence of SQL
  commands over and over, possibly in multiple concurrent database sessions,
  and then calculates the average transaction rate (transactions per second).
  By default, <application>pgbench</application> tests a scenario that is
  loosely based on TPC-B, involving five <command>SELECT</>,
  <command>UPDATE</>, and <command>INSERT</> commands per transaction.
  However, it is easy to test other cases by writing your own transaction
  script files.
 </para>
____________________________________________________________________________-->
 <para>
  <application>pgbench</application>是一种在<productname>PostgreSQL</>上运行基准测试的简单程序。它可能在并发的数据库会话中一遍一遍地运行相同序列的 SQL 命令，并且计算平均事务率（每秒的事务数）。默认情况下，<application>pgbench</application>会测试一种基于 TPC-B 但是要更宽松的场景，其中在每个事务中涉及五个<command>SELECT</>、<command>UPDATE</>以及<command>INSERT</>命令。但是，通过编写自己的事务脚本文件很容易用来测试其他情况。
 </para>

<!--==========================orignal english content==========================
 <para>
  Typical output from <application>pgbench</application> looks like:

<screen>
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)
</screen>

  The first six lines report some of the most important parameter
  settings.  The next line reports the number of transactions completed
  and intended (the latter being just the product of number of clients
  and number of transactions per client); these will be equal unless the run
  failed before completion.  (In <option>-T</> mode, only the actual
  number of transactions is printed.)
  The last two lines report the number of transactions per second,
  figured with and without counting the time to start database sessions.
 </para>
____________________________________________________________________________-->
 <para>
  <application>pgbench</application>的典型输出像这样：

<screen>
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)
</screen>

  前六行报告一些最重要的参数设置。接下来的行报告完成的事务数以及预期的事务数（后者就是客户端数量与每个客户端事务数的乘积），除非运行在完成之前失败，这些值应该是相等的（在<option>-T</>模式中，只有实际的事务数会被打印出来）。最后两行报告每秒的事务数，分别代表包括和不包括开始数据库会话所花时间的情况。
 </para>

<!--==========================orignal english content==========================
  <para>
   The default TPC-B-like transaction test requires specific tables to be
   set up beforehand.  <application>pgbench</> should be invoked with
   the <option>-i</> (initialize) option to create and populate these
   tables.  (When you are testing a custom script, you don't need this
   step, but will instead need to do whatever setup your test needs.)
   Initialization looks like:

<programlisting>
pgbench -i <optional> <replaceable>other-options</> </optional> <replaceable>dbname</>
</programlisting>

   where <replaceable>dbname</> is the name of the already-created
   database to test in.  (You may also need <option>-h</>,
   <option>-p</>, and/or <option>-U</> options to specify how to
   connect to the database server.)
  </para>
____________________________________________________________________________-->
  <para>
   默认的类 TPC-B 事务测试要求预先设置好特定的表。可以使用<option>-i</>（初始化）选项调用<application>pgbench</>来创建并且填充这些表（当你在测试一个自定义脚本时，你不需要这一步，但是需要按你自己的测试需要做一些设置工作）。初始化类似这样：

<programlisting>
pgbench -i <optional> <replaceable>other-options</> </optional> <replaceable>dbname</>
</programlisting>

   其中<replaceable>dbname</>是要在其中进行测试的预先创建好的数据库的名称（你可能还需要<option>-h</>、<option>-p</>或<option>-U</>选项来指定如何连接到数据库服务器）。
  </para>

  <caution>
<!--==========================orignal english content==========================
   <para>
    <literal>pgbench -i</> creates four tables <structname>pgbench_accounts</>,
    <structname>pgbench_branches</>, <structname>pgbench_history</>, and
    <structname>pgbench_tellers</>,
    destroying any existing tables of these names.
    Be very careful to use another database if you have tables having these
    names!
   </para>
____________________________________________________________________________-->
   <para>
    <literal>pgbench -i</>会创建四个表<structname>pgbench_accounts</>、
    <structname>pgbench_branches</>、<structname>pgbench_history</>以及<structname>pgbench_tellers</>，如果同名表已经存在会被先删除。如果你已经有同名表，一定注意要使用另一个数据库！
   </para>
  </caution>

<!--==========================orignal english content==========================
  <para>
   At the default <quote>scale factor</> of 1, the tables initially
   contain this many rows:
<screen>
table                   # of rows
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0
</screen>
   You can (and, for most purposes, probably should) increase the number
   of rows by using the <option>-s</> (scale factor) option.  The
   <option>-F</> (fillfactor) option might also be used at this point.
  </para>
____________________________________________________________________________-->
  <para>
   在默认的情况下<quote>比例因子</>为 1，这些表初始包含的行数为：
<screen>
table                   # of rows
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0
</screen>
   你可以使用<option>-s</>（比例因子）选项增加行的数量。<option>-F</>（填充因子）选项也可以在这里使用。
  </para>

<!--==========================orignal english content==========================
  <para>
   Once you have done the necessary setup, you can run your benchmark
   with a command that doesn't include <option>-i</>, that is

<programlisting>
pgbench <optional> <replaceable>options</> </optional> <replaceable>dbname</>
</programlisting>

   In nearly all cases, you'll need some options to make a useful test.
   The most important options are <option>-c</> (number of clients),
   <option>-t</> (number of transactions), <option>-T</> (time limit),
   and <option>-f</> (specify a custom script file).
   See below for a full list.
  </para>
____________________________________________________________________________-->
  <para>
   一旦你完成了必要的设置，你就可以用不包括<option>-i</>的命令运行基准，也就是：

<programlisting>
pgbench <optional> <replaceable>options</> </optional> <replaceable>dbname</>
</programlisting>

   在近乎所有的情况中，你将需要一些选项来做一次有用的测试。最重要的选项是<option>-c</>（客户端数量）、
   <option>-t</>（事务数量）、<option>-T</>（时间限制）以及<option>-f</>（指定一个自定义脚本文件）。完整的列表见下文。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Options</title>
____________________________________________________________________________-->
  <title>选项</title>

<!--==========================orignal english content==========================
  <para>
   The following is divided into three subsections: Different options are used
   during database initialization and while running benchmarks, some options
   are useful in both cases.
  </para>
____________________________________________________________________________-->
  <para>
   下面分成三个部分：数据库初始化期间使用的选项、运行基准时使用的选项、两种情况下都有用的选项。
  </para>

 <refsect2 id="pgbench-init-options">
<!--==========================orignal english content==========================
  <title>Initialization Options</title>
____________________________________________________________________________-->
  <title>初始化选项</title>

<!--==========================orignal english content==========================
   <para>
    <application>pgbench</application> accepts the following command-line
    initialization arguments:

    <variablelist>

     <varlistentry>
      <term><option>-i</option></term>
      <term><option>-&minus;initialize</option></term>
      <listitem>
       <para>
        Required to invoke initialization mode.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-F</option> <replaceable>fillfactor</></term>
      <term><option>-&minus;fillfactor=</option><replaceable>fillfactor</></term>
      <listitem>
       <para>
        Create the <structname>pgbench_accounts</>,
        <structname>pgbench_tellers</> and
        <structname>pgbench_branches</> tables with the given fillfactor.
        Default is 100.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>-&minus;no-vacuum</option></term>
      <listitem>
       <para>
        Perform no vacuuming after initialization.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-q</option></term>
      <term><option>-&minus;quiet</option></term>
      <listitem>
       <para>
        Switch logging to quiet mode, producing only one progress message per 5
        seconds. The default logging prints one message each 100000 rows, which
        often outputs many lines per second (especially on good hardware).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</></term>
      <term><option>-&minus;scale=</option><replaceable>scale_factor</></term>
      <listitem>
       <para>
        Multiply the number of rows generated by the scale factor.
        For example, <literal>-s 100</> will create 10,000,000 rows
        in the <structname>pgbench_accounts</> table. Default is 1.
        When the scale is 20,000 or larger, the columns used to
        hold account identifiers (<structfield>aid</structfield> columns)
        will switch to using larger integers (<type>bigint</type>),
        in order to be big enough to hold the range of account
        identifiers.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;foreign-keys</option></term>
      <listitem>
       <para>
        Create foreign key constraints between the standard tables.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;index-tablespace=<replaceable>index_tablespace</replaceable></option></term>
      <listitem>
       <para>
        Create indexes in the specified tablespace, rather than the default
        tablespace.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;tablespace=<replaceable>tablespace</replaceable></option></term>
      <listitem>
       <para>
        Create tables in the specified tablespace, rather than the default
        tablespace.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;unlogged-tables</option></term>
      <listitem>
       <para>
        Create all tables as unlogged tables, rather than permanent tables.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <application>pgbench</application>接受下列命令行初始化参数：

    <variablelist>

     <varlistentry>
      <term><option>-i</option></term>
      <term><option>--initialize</option></term>
      <listitem>
       <para>
        要求调用初始化模式。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-F</option> <replaceable>fillfactor</></term>
      <term><option>--fillfactor=</option><replaceable>fillfactor</></term>
      <listitem>
       <para>
        用给定的填充因子创建<structname>pgbench_accounts</>、
        <structname>pgbench_tellers</>和
        <structname>pgbench_branches</>表。默认值是 100。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
        初始化以后不执行清理。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-q</option></term>
      <term><option>--quiet</option></term>
      <listitem>
       <para>
        把记录切换到安静模式，只是每 5 秒产生一个进度消息。默认的记录会每 100000 行打印一个消息，这经常会在每秒钟输出很多行（特别是在好的硬件上）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</></term>
      <term><option>--scale=</option><replaceable>scale_factor</></term>
      <listitem>
       <para>
        将生成的行数乘以比例因子。例如，<literal>-s 100</>将在<structname>pgbench_accounts</>表中创建 10,000,000 行。默认为 1。当比例为 20,000 或更高时，用来保存账号标识符的列（<structfield>aid</structfield>列）将切换到使用更大的整数（<type>bigint</type>），这样才能足以保存账号标识符。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--foreign-keys</option></term>
      <listitem>
       <para>
        在标准的表之间创建外键约束。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--index-tablespace=<replaceable>index_tablespace</replaceable></option></term>
      <listitem>
       <para>
        在指定的表空间而不是默认表空间中创建索引。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--tablespace=<replaceable>tablespace</replaceable></option></term>
      <listitem>
       <para>
        在指定的表空间而不是默认表空间中创建表。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--unlogged-tables</option></term>
      <listitem>
       <para>
        把所有的表创建为非日志记录表而不是永久表。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect2>

 <refsect2 id="pgbench-run-options">
<!--==========================orignal english content==========================
  <title>Benchmarking Options</title>
____________________________________________________________________________-->
  <title>基准选项</title>

<!--==========================orignal english content==========================
   <para>
    <application>pgbench</application> accepts the following command-line
    benchmarking arguments:

    <variablelist>
     <varlistentry>
      <term><option>-b</> <replaceable>scriptname[@weight]</></term>
      <term><option>-&minus;builtin</>=<replaceable>scriptname[@weight]</></term>
      <listitem>
       <para>
        Add the specified built-in script to the list of executed scripts.
        An optional integer weight after <literal>@</> allows to adjust the
        probability of drawing the script.  If not specified, it is set to 1.
        Available built-in scripts are: <literal>tpcb-like</>,
        <literal>simple-update</> and <literal>select-only</>.
        Unambiguous prefixes of built-in names are accepted.
        With special name <literal>list</>, show the list of built-in scripts
        and exit immediately.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><option>-c</option> <replaceable>clients</></term>
      <term><option>-&minus;client=</option><replaceable>clients</></term>
      <listitem>
       <para>
        Number of clients simulated, that is, number of concurrent database
        sessions.  Default is 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-C</option></term>
      <term><option>-&minus;connect</option></term>
      <listitem>
       <para>
        Establish a new connection for each transaction, rather than
        doing it just once per client session.
        This is useful to measure the connection overhead.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option></term>
      <term><option>-&minus;debug</option></term>
      <listitem>
       <para>
        Print debugging output.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>varname</><literal>=</><replaceable>value</></term>
      <term><option>-&minus;define=</option><replaceable>varname</><literal>=</><replaceable>value</></term>
      <listitem>
       <para>
        Define a variable for use by a custom script (see below).
        Multiple <option>-D</> options are allowed.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-f</> <replaceable>filename[@weight]</></term>
      <term><option>-&minus;file=</><replaceable>filename[@weight]</></term>
      <listitem>
       <para>
        Add a transaction script read from <replaceable>filename</> to
        the list of executed scripts.
        An optional integer weight after <literal>@</> allows to adjust the
        probability of drawing the test.
        See below for details.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j</option> <replaceable>threads</></term>
      <term><option>-&minus;jobs=</option><replaceable>threads</></term>
      <listitem>
       <para>
        Number of worker threads within <application>pgbench</application>.
        Using more than one thread can be helpful on multi-CPU machines.
        Clients are distributed as evenly as possible among available threads.
        Default is 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-l</option></term>
      <term><option>-&minus;log</option></term>
      <listitem>
       <para>
        Write information about each transaction to a log file.
        See below for details.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-L</option> <replaceable>limit</></term>
      <term><option>-&minus;latency-limit=</option><replaceable>limit</></term>
      <listitem>
       <para>
        Transaction which last more than <replaceable>limit</> milliseconds
        are counted and reported separately, as <firstterm>late</>.
       </para>
       <para>
        When throttling is used (<option>-&minus;rate=...</>), transactions that
        lag behind schedule by more than <replaceable>limit</> ms, and thus
        have no hope of meeting the latency limit, are not sent to the server
        at all. They are counted and reported separately as
        <firstterm>skipped</>.
       </para>
       </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-M</option> <replaceable>querymode</></term>
      <term><option>-&minus;protocol=</option><replaceable>querymode</></term>
      <listitem>
       <para>
        Protocol to use for submitting queries to the server:
          <itemizedlist>
           <listitem>
            <para><literal>simple</>: use simple query protocol.</para>
           </listitem>
           <listitem>
            <para><literal>extended</>: use extended query protocol.</para>
           </listitem>
           <listitem>
            <para><literal>prepared</>: use extended query protocol with prepared statements.</para>
           </listitem>
          </itemizedlist>
        The default is simple query protocol.  (See <xref linkend="protocol">
        for more information.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>-&minus;no-vacuum</option></term>
      <listitem>
       <para>
        Perform no vacuuming before running the test.
        This option is <emphasis>necessary</>
        if you are running a custom test scenario that does not include
        the standard tables <structname>pgbench_accounts</>,
        <structname>pgbench_branches</>, <structname>pgbench_history</>, and
        <structname>pgbench_tellers</>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-N</option></term>
      <term><option>-&minus;skip-some-updates</option></term>
      <listitem>
       <para>
        Run built-in simple-update script.
        Shorthand for <option>-b simple-update</>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-P</option> <replaceable>sec</></term>
      <term><option>-&minus;progress=</option><replaceable>sec</></term>
      <listitem>
       <para>
        Show progress report every <replaceable>sec</> seconds.  The report
        includes the time since the beginning of the run, the tps since the
        last report, and the transaction latency average and standard
        deviation since the last report.  Under throttling (<option>-R</>),
        the latency is computed with respect to the transaction scheduled
        start time, not the actual transaction beginning time, thus it also
        includes the average schedule lag time.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-r</option></term>
      <term><option>-&minus;report-latencies</option></term>
      <listitem>
       <para>
        Report the average per-statement latency (execution time from the
        perspective of the client) of each command after the benchmark
        finishes.  See below for details.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-R</option> <replaceable>rate</></term>
      <term><option>-&minus;rate=</option><replaceable>rate</></term>
      <listitem>
       <para>
        Execute transactions targeting the specified rate instead of running
        as fast as possible (the default).  The rate is given in transactions
        per second.  If the targeted rate is above the maximum possible rate,
        the rate limit won't impact the results.
       </para>
       <para>
        The rate is targeted by starting transactions along a
        Poisson-distributed schedule time line.  The expected start time
        schedule moves forward based on when the client first started, not
        when the previous transaction ended.  That approach means that when
        transactions go past their original scheduled end time, it is
        possible for later ones to catch up again.
       </para>
       <para>
        When throttling is active, the transaction latency reported at the
        end of the run is calculated from the scheduled start times, so it
        includes the time each transaction had to wait for the previous
        transaction to finish. The wait time is called the schedule lag time,
        and its average and maximum are also reported separately. The
        transaction latency with respect to the actual transaction start time,
        i.e. the time spent executing the transaction in the database, can be
        computed by subtracting the schedule lag time from the reported
        latency.
       </para>

       <para>
        If <option>-&minus;latency-limit</> is used together with <option>-&minus;rate</>,
        a transaction can lag behind so much that it is already over the
        latency limit when the previous transaction ends, because the latency
        is calculated from the scheduled start time. Such transactions are
        not sent to the server, but are skipped altogether and counted
        separately.
       </para>

       <para>
        A high schedule lag time is an indication that the system cannot
        process transactions at the specified rate, with the chosen number of
        clients and threads. When the average transaction execution time is
        longer than the scheduled interval between each transaction, each
        successive transaction will fall further behind, and the schedule lag
        time will keep increasing the longer the test run is. When that
        happens, you will have to reduce the specified transaction rate.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</></term>
      <term><option>-&minus;scale=</option><replaceable>scale_factor</></term>
      <listitem>
       <para>
        Report the specified scale factor in <application>pgbench</>'s
        output.  With the built-in tests, this is not necessary; the
        correct scale factor will be detected by counting the number of
        rows in the <structname>pgbench_branches</> table.
        However, when testing only custom benchmarks (<option>-f</> option),
        the scale factor will be reported as 1 unless this option is used.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-S</option></term>
      <term><option>-&minus;select-only</option></term>
      <listitem>
       <para>
        Run built-in select-only script.
        Shorthand for <option>-b select-only</>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-t</option> <replaceable>transactions</></term>
      <term><option>-&minus;transactions=</option><replaceable>transactions</></term>
      <listitem>
       <para>
        Number of transactions each client runs.  Default is 10.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-T</option> <replaceable>seconds</></term>
      <term><option>-&minus;time=</option><replaceable>seconds</></term>
      <listitem>
       <para>
        Run the test for this many seconds, rather than a fixed number of
        transactions per client. <option>-t</option> and
        <option>-T</option> are mutually exclusive.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>-&minus;vacuum-all</option></term>
      <listitem>
       <para>
        Vacuum all four standard tables before running the test.
        With neither <option>-n</> nor <option>-v</>, <application>pgbench</application> will vacuum the
        <structname>pgbench_tellers</> and <structname>pgbench_branches</>
        tables, and will truncate <structname>pgbench_history</>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;aggregate-interval=<replaceable>seconds</></option></term>
      <listitem>
       <para>
        Length of aggregation interval (in seconds).  May be used only
        with <option>-l</option> option.  With this option, the log contains
        per-interval summary data, as described below.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;log-prefix=<replaceable>prefix</></option></term>
      <listitem>
       <para>
        Set the filename prefix for the log files created by
        <option>-&minus;log</>.  The default is <literal>pgbench_log</>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;progress-timestamp</option></term>
      <listitem>
       <para>
        When showing progress (option <option>-P</>), use a timestamp
        (Unix epoch) instead of the number of seconds since the
        beginning of the run.  The unit is in seconds, with millisecond
        precision after the dot.
        This helps compare logs generated by various tools.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-&minus;sampling-rate=<replaceable>rate</></option></term>
      <listitem>
       <para>
        Sampling rate, used when writing data into the log, to reduce the
        amount of log generated. If this option is given, only the specified
        fraction of transactions are logged. 1.0 means all transactions will
        be logged, 0.05 means only 5% of the transactions will be logged.
       </para>
       <para>
        Remember to take the sampling rate into account when processing the
        log file. For example, when computing tps values, you need to multiply
        the numbers accordingly (e.g. with 0.01 sample rate, you'll only get
        1/100 of the actual tps).
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <application>pgbench</application>接受下列命令行基准参数：

    <variablelist>
     <varlistentry>
      <term><option>-b</> <replaceable>scriptname[@weight]</></term>
      <term><option>--builtin</>=<replaceable>scriptname[@weight]</></term>
      <listitem>
       <para>
        把指定的内建脚本加入到要执行的脚本列表中。<literal>@</>之后是一个可选的整数权重，它允许调节抽取该脚本的可能性。如果没有指定，它会被设置为 1。可用的内建脚本有：<literal>tpcb-like</>、<literal>simple-update</>和<literal>select-only</>。这里也接受内建名称无歧义的前缀缩写。如果用上特殊的名字<literal>list</>，将会显示内建脚本的列表并且立刻退出。
       </para>
      </listitem>
     </varlistentry>
      
     <varlistentry>
      <term><option>-c</option> <replaceable>clients</></term>
      <term><option>--client=</option><replaceable>clients</></term>
      <listitem>
       <para>
        模拟的客户端数量，也就是并发数据库会话数量。默认为 1。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-C</option></term>
      <term><option>--connect</option></term>
      <listitem>
       <para>
        为每一个事务建立一个新连接，而不是只为每个客户端会话建立一个连接。这对于度量连接开销有用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option></term>
      <term><option>--debug</option></term>
      <listitem>
       <para>
        打印调试输出。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>varname</><literal>=</><replaceable>value</></term>
      <term><option>--define=</option><replaceable>varname</><literal>=</><replaceable>value</></term>
      <listitem>
       <para>
        定义一个由自定义脚本（见下文）使用的变量。允许多个<option>-D</>选项。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-f</> <replaceable>filename[@weight]</></term>
      <term><option>--file=</><replaceable>filename[@weight]</></term>
      <listitem>
       <para>
        把一个从<replaceable>filename</>读到的事务脚本加入到被执行的脚本列表中。<literal>@</>后面是一个可选的整数权重，它允许调节抽取该测试的可能性。详见下文。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j</option> <replaceable>threads</></term>
      <term><option>--jobs=</option><replaceable>threads</></term>
      <listitem>
       <para>
        <application>pgbench</application>中的工作者线程数量。在多 CPU 机器上使用多于一个线程会有用。客户端会尽可能均匀地分布到可用的线程上。默认为 1。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-l</option></term>
      <term><option>--log</option></term>
      <listitem>
       <para>
        把每一个事务的信息写到一个日志文件中。详见下文。
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><option>-L</option> <replaceable>limit</></term>
      <term><option>--latency-limit=</option><replaceable>limit</></term>
      <listitem>
       <para>
        对持续超过<replaceable>limit</>毫秒的事务进行独立的计数和报告，
        这些事务被认为是<firstterm>迟到（late）</>了的事务。
       </para>
       <para>
        在使用限流措施时（<option>--rate=...</>），滞后于计划超过
        <replaceable>limit</>毫秒并且因此没有希望满足延迟限制的事务根本
        不会被发送给服务器。这些事务被认为是<firstterm>被跳过（skipped）</>
        的事务，它们会被单独计数并且报告。
       </para>
       </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-M</option> <replaceable>querymode</></term>
      <term><option>--protocol=</option><replaceable>querymode</></term>
      <listitem>
       <para>
        要用来提交查询到服务器的协议：
          <itemizedlist>
           <listitem>
            <para><literal>simple</>：使用简单查询协议。</para>
           </listitem>
           <listitem>
            <para><literal>extended</>使用扩展查询协议。</para>
           </listitem>
           <listitem>
            <para><literal>prepared</>：使用带预备语句的扩展查询语句。</para>
           </listitem>
          </itemizedlist>
        默认是简单查询协议（详见<xref linkend="protocol">）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
        在运行测试前不进行清理。如果你在运行一个不包括标准的表<structname>pgbench_accounts</>、
        <structname>pgbench_branches</>、<structname>pgbench_history</>和
        <structname>pgbench_tellers</>的自定义测试场景时，这个选项是<emphasis>必需的</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-N</option></term>
      <term><option>--skip-some-updates</option></term>
      <listitem>
       <para>
        运行内建的简单更新脚本。这是<option>-b simple-update</>的简写。
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><option>-P</option> <replaceable>sec</></term>
      <term><option>--progress=</option><replaceable>sec</></term>
      <listitem>
       <para>
        每<replaceable>sec</>秒显示进度报告。该报告包括运行了多长时间、从上次报告以来的 tps 以及从上次报告以来事务延迟的平均值和标准偏差。如果低于限流值（<option>-R</>），延迟会相对于事务预定的开始时间（而不是实际的事务开始时间）计算，因此其中也包括了平均调度延迟时间。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-r</option></term>
      <term><option>--report-latencies</option></term>
      <listitem>
       <para>
        在基准结束后，报告平均的每个命令的每语句等待时间（从客户端的角度来说是执行时间）。详见下文。
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><option>-R</option> <replaceable>rate</></term>
      <term><option>--rate=</option><replaceable>rate</></term>
      <listitem>
       <para>
        按照指定的速率执行事务而不是尽可能快地执行（默认行为）。该速率
        以 tps（每秒事务数）形式给定。如果目标速率高于最大可能速率，则
        该速率限制不会影响结果。
       </para>
       <para>
        该速率的目标是按照一条泊松分布的调度时间线开始事务。期望的开始
        时间表会基于客户端第一次开始的时间（而不是上一个事务结束的时
        间）前移。这种方法意味着当事务超过它们的原定结束时间时，更迟的
        那些有机会再次追赶上来。
       </para>
       <para>
        当限流措施被激活时，运行结束时报告的事务延迟是从预订的开始时间计
        算而来的，因此它包括每一个事务不得不等待前一个事务结束所花的时
        间。该等待时间被称作调度延迟时间，并且它的平均值和最大值也会被
        单独报告。关于实际事务开始时间的事务延迟（即在数据库中执行事务
        所花的时间）可以用报告的延迟减去调度延迟时间计算得到。
       </para>
       
       <para>
        如果把<option>--latency-limit</>和<option>--rate</>一起使用，
        当一个事务在前一个事务结束时已经超过了延迟限制时，它可能会滞后
        非常多，因为延迟是从计划的开始时间计算得来。这类事务不会被发送
        给服务器，而是一起被跳过并且被单独计数。
       </para>

       <para>
        一个高的调度延迟时间表示系统无法用选定的客户端和线程数按照指定
        的速率处理事务。当平均的事务执行时间超过每个事务之间的调度间隔
        时，每一个后续事务将会落后更多，并且随着测试运行时间越长，调度
        延迟时间将持续增加。发生这种情况时，你将不得不降低指定的事务速率。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</></term>
      <term><option>--scale=</option><replaceable>scale_factor</></term>
      <listitem>
       <para>
        在<application>pgbench</>的输出中报告指定的比例因子。对于内建测试，这并非必需；正确的比例因子将通过对<structname>pgbench_branches</>表中的行计数来检测。不过，当只测试自定义基准（<option>-f</>选项）时，比例因子将被报告为 1（除非使用了这个选项）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-S</option></term>
      <term><option>--select-only</option></term>
      <listitem>
       <para>
        执行内建的只有选择的脚本。是<option>-b select-only</>简写形式。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-t</option> <replaceable>transactions</></term>
      <term><option>--transactions=</option><replaceable>transactions</></term>
      <listitem>
       <para>
        每个客户端运行的事务数量。默认为 10。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-T</option> <replaceable>seconds</></term>
      <term><option>--time=</option><replaceable>seconds</></term>
      <listitem>
       <para>
        运行测试这么多秒，而不是为每个客户端运行固定数量的事务。<option>-t</option>和<option>-T</option>是互斥的。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>--vacuum-all</option></term>
      <listitem>
       <para>
        在运行测试前清理所有四个标准的表。在没有用<option>-n</>以及<option>-v</>时，
        <application>pgbench</application>将清理<structname>pgbench_tellers</>
        和<structname>pgbench_branches</>表，并且截断<structname>pgbench_history</>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--aggregate-interval=<replaceable>seconds</></option></term>
      <listitem>
       <para>
        聚集区间的长度（以秒计）。可以只与<option>-l</option>选项一起使用。
		通过这个选项，日志会包含每个区间的总结，如下所述。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--log-prefix=<replaceable>prefix</></option></term>
      <listitem>
       <para>
        为由<option>--log</>创建的日志文件设置文件名前缀。
		默认值是<literal>pgbench_log</>。
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
      <term><option>--progress-timestamp</option></term>
      <listitem>
       <para>
        当显示进度（选项<option>-P</>）时，使用一个时间戳（Unix 时间）取代从运行开始的秒数。单位是秒，在小数点后是毫秒精度。这可以有助于比较多种工具生成的日志。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--sampling-rate=<replaceable>rate</></option></term>
      <listitem>
       <para>
        采样率，在写入数据到日志时被用来减少日志产生的数量。如果给出这个选项，只有指定比例的事务被记录。1.0 表示所有事务都将被记录，0.05 表示只有 5% 的事务会被记录。
       </para>
       <para>
        在处理日志文件时，记得要考虑这个采样率。例如，当计算 tps 值时，你需要相应地乘以这个数字（例如，采样率是 0.01，你将只能得到实际 tps 的 1/100）。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect2>

 <refsect2 id="pgbench-common-options">
<!--==========================orignal english content==========================
  <title>Common Options</title>
____________________________________________________________________________-->
  <title>普通选项</title>

<!--==========================orignal english content==========================
   <para>
    <application>pgbench</application> accepts the following command-line
    common arguments:

    <variablelist>

     <varlistentry>
      <term><option>-h</option> <replaceable>hostname</></term>
      <term><option>-&minus;host=</option><replaceable>hostname</></term>
      <listitem>
       <para>
        The database server's host name
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option> <replaceable>port</></term>
      <term><option>-&minus;port=</option><replaceable>port</></term>
      <listitem>
       <para>
        The database server's port number
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U</option> <replaceable>login</></term>
      <term><option>-&minus;username=</option><replaceable>login</></term>
      <listitem>
       <para>
        The user name to connect as
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-V</></term>
      <term><option>-&minus;version</></term>
      <listitem>
       <para>
        Print the <application>pgbench</application> version and exit.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-?</></term>
      <term><option>-&minus;help</></term>
      <listitem>
       <para>
        Show help about <application>pgbench</application> command line
        arguments, and exit.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <application>pgbench</application>接受下列命令行普通参数：

    <variablelist>

     <varlistentry>
      <term><option>-h</option> <replaceable>hostname</></term>
      <term><option>--host=</option><replaceable>hostname</></term>
      <listitem>
       <para>
        数据库服务器的主机名
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option> <replaceable>port</></term>
      <term><option>--port=</option><replaceable>port</></term>
      <listitem>
       <para>
        数据库服务器的端口号
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U</option> <replaceable>login</></term>
      <term><option>--username=</option><replaceable>login</></term>
      <listitem>
       <para>
        要作为哪个用户连接
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-V</></term>
      <term><option>--version</></term>
      <listitem>
       <para>
        打印<application>pgbench</application>版本并退出。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-?</></term>
      <term><option>--help</></term>
      <listitem>
       <para>
        显示有关<application>pgbench</application>命令行参数的信息，并且退出。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

 </refsect2>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

 <refsect2>
<!--==========================orignal english content==========================
  <title>What is the <quote>Transaction</> Actually Performed in <application>pgbench</application>?</title>
____________________________________________________________________________-->
  <title>在<application>pgbench</application>中实际执行的<quote>事务</>是什么？</title>

<!--==========================orignal english content==========================
  <para>
   <application>pgbench</> executes test scripts chosen randomly
   from a specified list.
   They include built-in scripts with <option>-b</> and
   user-provided custom scripts with <option>-f</>.
   Each script may be given a relative weight specified after a
   <literal>@</> so as to change its drawing probability.
   The default weight is <literal>1</>.
   Scripts with a weight of <literal>0</> are ignored.
 </para>
____________________________________________________________________________-->
  <para>
   <application>pgbench</>执行从指定列表中随机选中的测试脚本。它们包括带有<option>-b</>的内建脚本和带有<option>-f</>的用户提供的自定义脚本。每一个脚本可以在其后用<literal>@</>指定一个相对权重，这样可以更改该脚本的抽取概率。默认权重是<literal>1</>。权重为<literal>0</>的脚本会被忽略。
 </para>

<!--==========================orignal english content==========================
  <para>
   The default built-in transaction script (also invoked with <option>-b tpcb-like</>)
   issues seven commands per transaction over randomly chosen <literal>aid</>,
   <literal>tid</>, <literal>bid</> and <literal>balance</>.
   The scenario is inspired by the TPC-B benchmark, but is not actually TPC-B,
   hence the name.
  </para>
____________________________________________________________________________-->
  <para>
   默认的内建事务脚本（也会被<option>-b tpcb-like</>调用）会在每个事务上发出七个从<literal>aid</>、<literal>tid</>、<literal>bid</>和<literal>balance</>中随机选择的命令。该场景来自于 TPC-B 基准，但并不是真正的 TPC-B，只是名字像而已。
  </para>

  <orderedlist>
   <listitem><!--==========================orignal english content==========================
<para><literal>BEGIN;</literal></para>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<para><literal>BEGIN;</literal></para>
____________________________________________________________________________-->
<para><literal>BEGIN;</literal></para></listitem>
   <listitem><!--==========================orignal english content==========================
<para><literal>UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</literal></para>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<para><literal>UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</literal></para>
____________________________________________________________________________-->
<para><literal>UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</literal></para></listitem>
   <listitem><!--==========================orignal english content==========================
<para><literal>SELECT abalance FROM pgbench_accounts WHERE aid = :aid;</literal></para>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<para><literal>SELECT abalance FROM pgbench_accounts WHERE aid = :aid;</literal></para>
____________________________________________________________________________-->
<para><literal>SELECT abalance FROM pgbench_accounts WHERE aid = :aid;</literal></para></listitem>
   <listitem><!--==========================orignal english content==========================
<para><literal>UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;</literal></para>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<para><literal>UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;</literal></para>
____________________________________________________________________________-->
<para><literal>UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;</literal></para></listitem>
   <listitem><!--==========================orignal english content==========================
<para><literal>UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;</literal></para>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<para><literal>UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;</literal></para>
____________________________________________________________________________-->
<para><literal>UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;</literal></para></listitem>
   <listitem><!--==========================orignal english content==========================
<para><literal>INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</literal></para>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<para><literal>INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</literal></para>
____________________________________________________________________________-->
<para><literal>INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</literal></para></listitem>
   <listitem><!--==========================orignal english content==========================
<para><literal>END;</literal></para>
____________________________________________________________________________-->
<!--==========================orignal english content==========================
<para><literal>END;</literal></para>
____________________________________________________________________________-->
<para><literal>END;</literal></para></listitem>
  </orderedlist>

<!--==========================orignal english content==========================
  <para>
   If you select the <literal>simple-update</> built-in (also <option>-N</>),
   steps 4 and 5 aren't included in the transaction.
   This will avoid update contention on these tables, but
   it makes the test case even less like TPC-B.
  </para>
____________________________________________________________________________-->
  <para>
   如果选择<literal>simple-update</>内建脚本（还有<option>-N</>），第 4 和 5 步不会被包括在事务中。这将避免更新那些表中的内容，但是它会让该测试用例更不像 TPC-B。
  </para>

<!--==========================orignal english content==========================
  <para>
   If you select the <literal>select-only</> built-in (also <option>-S</>),
   only the <command>SELECT</> is issued.
  </para>
____________________________________________________________________________-->
  <para>
   如果选择<literal>select-only</>内建脚本（还有<option>-S</>），只会发出<command>SELECT</>。
  </para>
 </refsect2>

 <refsect2>
<!--==========================orignal english content==========================
  <title>Custom Scripts</title>
____________________________________________________________________________-->
  <title>自定义脚本</title>

<!--==========================orignal english content==========================
  <para>
   <application>pgbench</application> has support for running custom
   benchmark scenarios by replacing the default transaction script
   (described above) with a transaction script read from a file
   (<option>-f</option> option).  In this case a <quote>transaction</>
   counts as one execution of a script file.
  </para>
____________________________________________________________________________-->
  <para>
   <application>pgbench</application>支持通过从一个文件中（<option>-f</option>选项）读取事务脚本替换默认的事务脚本（如上文所述）来运行自定义的基准场景。在这种情况中，一个<quote>事务</>就是一个脚本文件的一次执行。
  </para>

<!--==========================orignal english content==========================
  <para>
   A script file contains one or more SQL commands terminated by
   semicolons.  Empty lines and lines beginning with
   <literal>-&minus;</> are ignored.  Script files can also contain
   <quote>meta commands</>, which are interpreted by <application>pgbench</>
   itself, as described below.
  </para>
____________________________________________________________________________-->
  <para>
   脚本文件包含一个或者多个被分号终结的 SQL 命令。空行以及以<literal>--</>开始的行会被忽略。脚本文件也可以包含<quote>元命令</>，它会由<application>pgbench</>自身解释，详见下文。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    Before <productname>PostgreSQL</> 9.6, SQL commands in script files
    were terminated by newlines, and so they could not be continued across
    lines.  Now a semicolon is <emphasis>required</> to separate consecutive
    SQL commands (though a SQL command does not need one if it is followed
    by a meta command).  If you need to create a script file that works with
    both old and new versions of <application>pgbench</>, be sure to write
    each SQL command on a single line ending with a semicolon.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</> 9.6 之前，脚本文件中的 SQL 命令被新行终结，因此命令不能跨行。现在<emphasis>需要</>分号来分隔连续的 SQL 命令（如果 SQL 命令后面跟着一个元命令则不需要一个分号）。如果需要创建一个能在新旧版本<application>pgbench</>下工作的脚本文件，要确保把每个 SQL 命令写在一个由分号终结的行中。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   There is a simple variable-substitution facility for script files.
   Variables can be set by the command-line <option>-D</> option,
   explained above, or by the meta commands explained below.
   In addition to any variables preset by <option>-D</> command-line options,
   there are a few variables that are preset automatically, listed in
   <xref linkend="pgbench-automatic-variables">. A value specified for these
   variables using <option>-D</> takes precedence over the automatic presets.
   Once set, a variable's
   value can be inserted into a SQL command by writing
   <literal>:</><replaceable>variablename</>.  When running more than
   one client session, each session has its own set of variables.
  </para>
____________________________________________________________________________-->
  <para>
   对脚本文件有一种简单的变量替换功能。如上所述，变量可以用命令行的
   <option>-D</>选项设置，或者按下文所说的使用元命令设置。
   除了用<option>-D</>命令行选项预先设置的任何变量之外，
   还有一些被自动预先设置的变量，它们被列在
   <xref linkend="pgbench-automatic-variables">中。一个用<option>-D</>
   为这些变量值指定的值会优先于自动的预设值。
   一旦被设置，可以在 SQL 命令中写<literal>:</><replaceable>variablename</>
   来插入一个变量的值。当运行多于一个客户端会话时，
   每一个会话拥有它自己的变量集合。
   </para>
  
  <table id="pgbench-automatic-variables">
<!--==========================orignal english content==========================
    <title>Automatic Variables</title>
____________________________________________________________________________-->
    <title>自动变量</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Variable</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>变量</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry> <literal>scale</literal> </entry>
       <entry>current scale factor</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry> <literal>scale</literal> </entry>
       <entry>当前的缩放因子</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry> <literal>client_id</literal> </entry>
       <entry>unique number identifying the client session (starts from zero)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry> <literal>client_id</literal> </entry>
       <entry>标识该客户端会话的唯一数字（从零开始）</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   Script file meta commands begin with a backslash (<literal>\</>) and
   normally extend to the end of the line, although they can be continued
   to additional lines by writing backslash-return.
   Arguments to a meta command are separated by white space.
   These meta commands are supported:
  </para>
____________________________________________________________________________-->
  <para>
   脚本文件元命令开始于一个反斜线（<literal>\</>）并且通常延伸到行的末尾，
   尽管可以通过写入反斜杠返回来继续添加其他行。一个元命令和它的参数用空白分隔。支持的元命令是：
  </para>

  <variablelist>
   <varlistentry id='pgbench-metacommand-set'>
<!--==========================orignal english content==========================
    <term>
     <literal>\set <replaceable>varname</> <replaceable>expression</></literal>
    </term>
____________________________________________________________________________-->
    <term>
     <literal>\set <replaceable>varname</> <replaceable>expression</></literal>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Sets variable <replaceable>varname</> to a value calculated
      from <replaceable>expression</>.
      The expression may contain integer constants such as <literal>5432</>,
      double constants such as <literal>3.14159</>,
      references to variables <literal>:</><replaceable>variablename</>,
      unary operators (<literal>+</>, <literal>-</>) and binary operators
      (<literal>+</>, <literal>-</>, <literal>*</>, <literal>/</>,
      <literal>%</>) with their usual precedence and associativity,
      <link linkend="pgbench-builtin-functions">function calls</>, and
      parentheses.
     </para>
____________________________________________________________________________-->
     <para>
      把变量<replaceable>varname</>设置为一个从<replaceable>expression</>计算得到的值。该表达式可能会包含整数常量（例如<literal>5432</>）、双精度常量（例如<literal>3.14159</>）、对变量<literal>:</><replaceable>variablename</>的引用、一元（<literal>+</>、<literal>-</>）或者二元操作符（<literal>+</>、<literal>-</>、<literal>*</>、<literal>/</>、<literal>%</>）（保留它们通常的优先级、结合性和圆括号）。
     </para>

<!--==========================orignal english content==========================
     <para>
      Examples:
<programlisting>
\set ntellers 10 * :scale
\set aid (1021 * random(1, 100000 * :scale)) % \
           (100000 * :scale) + 1
</programlisting></para>
____________________________________________________________________________-->
     <para>
      例子：
<programlisting>
\set ntellers 10 * :scale
\set aid (1021 * random(1, 100000 * :scale)) % \
           (100000 * :scale) + 1
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <literal>\sleep <replaceable>number</> [ us | ms | s ]</literal>
    </term>
____________________________________________________________________________-->
    <term>
     <literal>\sleep <replaceable>number</> [ us | ms | s ]</literal>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Causes script execution to sleep for the specified duration in
      microseconds (<literal>us</>), milliseconds (<literal>ms</>) or seconds
      (<literal>s</>).  If the unit is omitted then seconds are the default.
      <replaceable>number</> can be either an integer constant or a
      <literal>:</><replaceable>variablename</> reference to a variable
      having an integer value.
     </para>
____________________________________________________________________________-->
     <para>
      导致脚本执行休眠指定的时间，时间的单位可以是微秒（<literal>us</>）、毫秒（<literal>ms</>）或者秒（<literal>s</>）。如果单位被忽略，则秒是默认值。<replaceable>number</>要么是一个整数常量，要么是一个引用了具有整数值的变量的<literal>:</><replaceable>variablename</>。
     </para>

<!--==========================orignal english content==========================
     <para>
      Example:
<programlisting>
\sleep 10 ms
</programlisting></para>
____________________________________________________________________________-->
     <para>
      例子：
<programlisting>
\sleep 10 ms
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <literal>\setshell <replaceable>varname</> <replaceable>command</> [ <replaceable>argument</> ... ]</literal>
    </term>
____________________________________________________________________________-->
    <term>
     <literal>\setshell <replaceable>varname</> <replaceable>command</> [ <replaceable>argument</> ... ]</literal>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Sets variable <replaceable>varname</> to the result of the shell command
      <replaceable>command</> with the given <replaceable>argument</>(s).
      The command must return an integer value through its standard output.
     </para>
____________________________________________________________________________-->
     <para>
      用给定的<replaceable>argument</>设置变量<replaceable>varname</>为 shell 命令<replaceable>command</>的结果。该命令必须通过它的标准输出返回一个整数值。
     </para>

<!--==========================orignal english content==========================
     <para>
      <replaceable>command</> and each <replaceable>argument</> can be either
      a text constant or a <literal>:</><replaceable>variablename</> reference
      to a variable. If you want to use an <replaceable>argument</> starting
      with a colon, write an additional colon at the beginning of
      <replaceable>argument</>.
     </para>
____________________________________________________________________________-->
     <para>
      <replaceable>command</>和每个<replaceable>argument</>要么是一个文本常量，要么是一个引用了一个变量的<literal>:</><replaceable>variablename</>。如果你想要使用以冒号开始的<replaceable>argument</>，在<replaceable>argument</>的开头写一个额外的冒号。
     </para>

<!--==========================orignal english content==========================
     <para>
      Example:
<programlisting>
\setshell variable_to_be_assigned command literal_argument :variable ::literal_starting_with_colon
</programlisting></para>
____________________________________________________________________________-->
     <para>
      例子：
<programlisting>
\setshell variable_to_be_assigned command literal_argument :variable ::literal_starting_with_colon
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <literal>\shell <replaceable>command</> [ <replaceable>argument</> ... ]</literal>
    </term>
____________________________________________________________________________-->
    <term>
     <literal>\shell <replaceable>command</> [ <replaceable>argument</> ... ]</literal>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      Same as <literal>\setshell</literal>, but the result of the command
      is discarded.
     </para>
____________________________________________________________________________-->
     <para>
      与<literal>\setshell</literal>相同，但是结果被抛弃。
     </para>

<!--==========================orignal english content==========================
     <para>
      Example:
<programlisting>
\shell command literal_argument :variable ::literal_starting_with_colon
</programlisting></para>
____________________________________________________________________________-->
     <para>
      例子：
<programlisting>
\shell command literal_argument :variable ::literal_starting_with_colon
</programlisting></para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect2>

 <refsect2 id="pgbench-builtin-functions">
<!--==========================orignal english content==========================
  <title>Built-In Functions</title>
____________________________________________________________________________-->
  <title>内建函数</title>

<!--==========================orignal english content==========================
  <para>
   The functions listed in <xref linkend="pgbench-functions"> are built
   into <application>pgbench</> and may be used in expressions appearing in
   <link linkend="pgbench-metacommand-set"><literal>\set</literal></link>.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="pgbench-functions">中列出的函数被编译在<application>pgbench</>中，并且可能被用在出现于<link linkend="pgbench-metacommand-set"><literal>\set</literal></link>的表达式中。
  </para>

   <!-- list pgbench functions in alphabetical order -->
   <table id="pgbench-functions">
<!--==========================orignal english content==========================
    <title>pgbench Functions</title>
____________________________________________________________________________-->
    <title>pgbench 函数</title>
    <tgroup cols="5">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>函数</entry>
       <entry>返回类型</entry>
       <entry>描述</entry>
       <entry>例子</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>abs(<replaceable>a</>)</></></>
       <entry>same as <replaceable>a</></>
       <entry>absolute value</>
       <entry><literal>abs(-17)</></>
       <entry><literal>17</></>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>abs(<replaceable>a</>)</></></>
       <entry>和<replaceable>a</>相同</>
       <entry>绝对值</>
       <entry><literal>abs(-17)</></>
       <entry><literal>17</></>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>debug(<replaceable>a</>)</></></>
       <entry>same as <replaceable>a</> </>
       <entry>print <replaceable>a</> to <systemitem>stderr</systemitem>,
        and return <replaceable>a</></>
       <entry><literal>debug(5432.1)</></>
       <entry><literal>5432.1</></>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>debug(<replaceable>a</>)</></></>
       <entry>和<replaceable>a</>相同</>
       <entry>把<replaceable>a</>打印到<systemitem>stderr</systemitem>，并且返回<replaceable>a</></>
       <entry><literal>debug(5432.1)</></>
       <entry><literal>5432.1</></>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>double(<replaceable>i</>)</></></>
       <entry>double</>
       <entry>cast to double</>
       <entry><literal>double(5432)</></>
       <entry><literal>5432.0</></>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>double(<replaceable>i</>)</></></>
       <entry>double</>
       <entry>转换成 double</>
       <entry><literal>double(5432)</></>
       <entry><literal>5432.0</></>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>greatest(<replaceable>a</> [, <replaceable>...</> ] )</></></>
       <entry>double if any <replaceable>a</> is double, else integer</>
       <entry>largest value among arguments</>
       <entry><literal>greatest(5, 4, 3, 2)</></>
       <entry><literal>5</></>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>greatest(<replaceable>a</> [, <replaceable>...</> ] )</></></>
       <entry>如果任何一个<replaceable>a</>是 double 则为 double，否则是 integer</>
       <entry>参数之中的最大值</>
       <entry><literal>greatest(5, 4, 3, 2)</></>
       <entry><literal>5</></>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>int(<replaceable>x</>)</></></>
       <entry>integer</>
       <entry>cast to int</>
       <entry><literal>int(5.4 + 3.8)</></>
       <entry><literal>9</></>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>int(<replaceable>x</>)</></></>
       <entry>integer</>
       <entry>转换成 int</>
       <entry><literal>int(5.4 + 3.8)</></>
       <entry><literal>9</></>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>least(<replaceable>a</> [, <replaceable>...</> ] )</></></>
       <entry>double if any <replaceable>a</> is double, else integer</>
       <entry>smallest value among arguments</>
       <entry><literal>least(5, 4, 3, 2.1)</></>
       <entry><literal>2.1</></>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>least(<replaceable>a</> [, <replaceable>...</> ] )</></></>
       <entry>如果任何一个<replaceable>a</>是 double 则为 double，否则是 integer</>
       <entry>参数之中的最小值</>
       <entry><literal>least(5, 4, 3, 2.1)</></>
       <entry><literal>2.1</></>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>pi()</></></>
       <entry>double</>
       <entry>value of the constant PI</>
       <entry><literal>pi()</></>
       <entry><literal>3.14159265358979323846</></>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>pi()</></></>
       <entry>double</>
       <entry>常量 PI 的值</>
       <entry><literal>pi()</></>
       <entry><literal>3.14159265358979323846</></>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>random(<replaceable>lb</>, <replaceable>ub</>)</></></>
       <entry>integer</>
       <entry>uniformly-distributed random integer in <literal>[lb, ub]</></>
       <entry><literal>random(1, 10)</></>
       <entry>an integer between <literal>1</> and <literal>10</></>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>random(<replaceable>lb</>, <replaceable>ub</>)</></></>
       <entry>integer</>
       <entry><literal>[lb, ub]</>中的均匀分布随机整数</>
       <entry><literal>random(1, 10)</></>
       <entry><literal>1</>和<literal>10</>之间的一个整数</>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>random_exponential(<replaceable>lb</>, <replaceable>ub</>, <replaceable>parameter</>)</></></>
       <entry>integer</>
       <entry>exponentially-distributed random integer in <literal>[lb, ub]</>,
              see below</>
       <entry><literal>random_exponential(1, 10, 3.0)</></>
       <entry>an integer between <literal>1</> and <literal>10</></>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>random_exponential(<replaceable>lb</>, <replaceable>ub</>, <replaceable>parameter</>)</></></>
       <entry>integer</>
       <entry><literal>[lb, ub]</>中的指数分布随机整数，见下文</>
       <entry><literal>random_exponential(1, 10, 3.0)</></>
       <entry><literal>1</>和<literal>10</>之间的一个整数</>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>random_gaussian(<replaceable>lb</>, <replaceable>ub</>, <replaceable>parameter</>)</></></>
       <entry>integer</>
       <entry>Gaussian-distributed random integer in <literal>[lb, ub]</>,
              see below</>
       <entry><literal>random_gaussian(1, 10, 2.5)</></>
       <entry>an integer between <literal>1</> and <literal>10</></>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>random_gaussian(<replaceable>lb</>, <replaceable>ub</>, <replaceable>parameter</>)</></></>
       <entry>integer</>
       <entry><literal>[lb, ub]</>中的高斯分布随机整数，见下文</>
       <entry><literal>random_gaussian(1, 10, 2.5)</></>
       <entry><literal>1</>和<literal>10</>之间的一个整数</>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal><function>sqrt(<replaceable>x</>)</></></>
       <entry>double</>
       <entry>square root</>
       <entry><literal>sqrt(2.0)</></>
       <entry><literal>1.414213562</></>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal><function>sqrt(<replaceable>x</>)</></></>
       <entry>double</>
       <entry>平方根</>
       <entry><literal>sqrt(2.0)</></>
       <entry><literal>1.414213562</></>
      </row>
     </tbody>
     </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    The <literal>random</> function generates values using a uniform
    distribution, that is all the values are drawn within the specified
    range with equal probability. The <literal>random_exponential</> and
    <literal>random_gaussian</> functions require an additional double
    parameter which determines the precise shape of the distribution.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>random</>函数使用均匀分布生成值，即所有的值都以相等的概率从指定的范围中抽出。<literal>random_exponential</>和<literal>random_gaussian</>函数要求一个额外的 double 参数，它决定分布的精确形状。
   </para>

   <itemizedlist>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      For an exponential distribution, <replaceable>parameter</>
      controls the distribution by truncating a quickly-decreasing
      exponential distribution at <replaceable>parameter</>, and then
      projecting onto integers between the bounds.
      To be precise, with
<literallayout>
f(x) = exp(-parameter * (x - min) / (max - min + 1)) / (1 - exp(-parameter))
</literallayout>
      Then value <replaceable>i</> between <replaceable>min</> and
      <replaceable>max</> inclusive is drawn with probability:
      <literal>f(i) - f(i + 1)</>.
     </para>
____________________________________________________________________________-->
     <para>
      对于指数分布，<replaceable>parameter</>通过在<replaceable>parameter</>处截断一个快速下降的指数分布来控制分布，然后投影到边界之间的整数上。确切地来说，
<literallayout>
f(x) = exp(-parameter * (x - min) / (max - min + 1)) / (1 - exp(-parameter))
</literallayout>
      然后<replaceable>min</>和<replaceable>max</>之间（包括两者）的值<replaceable>i</>会被以概率<literal>f(i) - f(i + 1)</>抽出。
     </para>

<!--==========================orignal english content==========================
     <para>
      Intuitively, the larger the <replaceable>parameter</>, the more
      frequently values close to <replaceable>min</> are accessed, and the
      less frequently values close to <replaceable>max</> are accessed.
      The closer to 0 <replaceable>parameter</> is, the flatter (more
      uniform) the access distribution.
      A crude approximation of the distribution is that the most frequent 1%
      values in the range, close to <replaceable>min</>, are drawn
      <replaceable>parameter</>% of the time.
      The <replaceable>parameter</> value must be strictly positive.
     </para>
____________________________________________________________________________-->
     <para>
      直观上，<replaceable>parameter</>越大，接近<replaceable>min</>的值会被越频繁地访问，并且接近<replaceable>max</>的值会被越少访问。<replaceable>parameter</>越接近 0，访问分布会越平坦（更均匀）。该分布的粗近似值是范围中当时被抽取 <replaceable>parameter</>% 次接近<replaceable>min</>的最频繁的 1% 值。<replaceable>parameter</>值必须严格为正。
     </para>
    </listitem>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      For a Gaussian distribution, the interval is mapped onto a standard
      normal distribution (the classical bell-shaped Gaussian curve) truncated
      at <literal>-parameter</> on the left and <literal>+parameter</>
      on the right.
      Values in the middle of the interval are more likely to be drawn.
      To be precise, if <literal>PHI(x)</> is the cumulative distribution
      function of the standard normal distribution, with mean <literal>mu</>
      defined as <literal>(max + min) / 2.0</>, with
<literallayout>
f(x) = PHI(2.0 * parameter * (x - mu) / (max - min + 1)) /
       (2.0 * PHI(parameter) - 1)
</literallayout>
      then value <replaceable>i</> between <replaceable>min</> and
      <replaceable>max</> inclusive is drawn with probability:
      <literal>f(i + 0.5) - f(i - 0.5)</>.
      Intuitively, the larger the <replaceable>parameter</>, the more
      frequently values close to the middle of the interval are drawn, and the
      less frequently values close to the <replaceable>min</> and
      <replaceable>max</> bounds. About 67% of values are drawn from the
      middle <literal>1.0 / parameter</>, that is a relative
      <literal>0.5 / parameter</> around the mean, and 95% in the middle
      <literal>2.0 / parameter</>, that is a relative
      <literal>1.0 / parameter</> around the mean; for instance, if
      <replaceable>parameter</> is 4.0, 67% of values are drawn from the
      middle quarter (1.0 / 4.0) of the interval (i.e. from
      <literal>3.0 / 8.0</> to <literal>5.0 / 8.0</>) and 95% from
      the middle half (<literal>2.0 / 4.0</>) of the interval (second and third
      quartiles). The minimum <replaceable>parameter</> is 2.0 for performance
      of the Box-Muller transform.
     </para>
____________________________________________________________________________-->
     <para>
      对于高斯分布，区间被映射到一个在左边<literal>-parameter</>和右边<literal>+parameter</>截断的标准正态分布（经典钟型高斯曲线）。区间中间的值更可能被抽到。准确地说，如果<literal>PHI(x)</>是标准正态分布的累计分布函数，均值<literal>mu</>定义为<literal>(max + min) / 2.0</>，有
<literallayout>
f(x) = PHI(2.0 * parameter * (x - mu) / (max - min + 1)) /
       (2.0 * PHI(parameter) - 1)
</literallayout>
      则<replaceable>min</>和<replaceable>max</>（包括两者）之间的值<replaceable>i</>被抽出的概率是：<literal>f(i + 0.5) - f(i - 0.5)</>。直观上，<replaceable>parameter</>越大，靠近区间终端的值会被越频繁地抽出，并且靠近上下界两端的值会被更少抽出。大约 67% 的值会被从中间<literal>1.0 / parameter</>的地方抽出，即均值周围<literal>0.5 / parameter</>的地方。并且 95% 的值会被从中间<literal>2.0 / parameter</>的地方抽出，即均值周围<literal>1.0 / parameter</>的地方。例如，如果<replaceable>parameter</>是 4.0，67% 的值会被从该区间的中间四分之一（1.0 / 4.0）抽出（即从<literal>3.0 / 8.0</>到<literal>5.0 / 8.0</>）。并且 95% 的值会从该区间的中间一半（<literal>2.0 / 4.0</>）抽出（第二和第三四分位）。为了 Box-Muller 变换的性能，<replaceable>parameter</>最小为 2.0。
     </para>
    </listitem>
   </itemizedlist>

<!--==========================orignal english content==========================
  <para>
   As an example, the full definition of the built-in TPC-B-like
   transaction is:

<programlisting>
\set aid random(1, 100000 * :scale)
\set bid random(1, 1 * :scale)
\set tid random(1, 10 * :scale)
\set delta random(-5000, 5000)
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;
</programlisting>

   This script allows each iteration of the transaction to reference
   different, randomly-chosen rows.  (This example also shows why it's
   important for each client session to have its own variables &mdash;
   otherwise they'd not be independently touching different rows.)
  </para>
____________________________________________________________________________-->
  <para>
   作为一个例子，内建的类 TPC-B 事务的全部定义是：

<programlisting>
\set aid random(1, 100000 * :scale)
\set bid random(1, 1 * :scale)
\set tid random(1, 10 * :scale)
\set delta random(-5000, 5000)
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;
</programlisting>

   这个脚本允许该事务的每一次迭代能够引用不同的、被随机选择的行（这个例子也展示了为什么让每一个客户端会话有其自己的变量很重要 &mdash; 否则它们不会独立地接触不同的行）。
  </para>

 </refsect2>

 <refsect2>
<!--==========================orignal english content==========================
  <title>Per-Transaction Logging</title>
____________________________________________________________________________-->
  <title>对每个事务做日志</title>

<!--==========================orignal english content==========================
  <para>
   With the <option>-l</> option (but without
   the <option>-&minus;aggregate-interval</option> option),
   <application>pgbench</> writes information about each transaction
   to a log file.  The log file will be named
   <filename><replaceable>prefix</>.<replaceable>nnn</></filename>,
   where <replaceable>prefix</> defaults to <literal>pgbench_log</>, and
   <replaceable>nnn</> is the PID of the
   <application>pgbench</application> process.
   The prefix can be changed by using the <option>-&minus;log-prefix</> option.
   If the <option>-j</> option is 2 or higher, so that there are multiple
   worker threads, each will have its own log file. The first worker will
   use the same name for its log file as in the standard single worker case.
   The additional log files for the other workers will be named
   <filename><replaceable>prefix</>.<replaceable>nnn</>.<replaceable>mmm</></filename>,
   where <replaceable>mmm</> is a sequential number for each worker starting
   with 1.
  </para>
____________________________________________________________________________-->
  <para>
   使用<option>-l</>选项但是不使用<option>--aggregate-interval</option>选项时，
   <application>pgbench</>会把每一个事务的信息写入到一个日志文件。
   该日志文件被命名为<filename><replaceable>prefix</>.<replaceable>nnn</></filename>，
   其中<replaceable>prefix</>默认是<literal>pgbench_log</>，
   <replaceable>nnn</>是<application>pgbench</application>进程的 PID。
   该前缀可以使用<option>--log-prefix</>选项修改。如果<option>-j</>选项是 2 或更高，
   那么有多个工作者进程，每一个将有自己的日志文件。
   第一个工作者将使用标准的单一工作者情形中相同的名称作为它的日志文件名。
   其他工作者的日志文件将被命名为<filename><replaceable>prefix</>.<replaceable>nnn</>.<replaceable>mmm</></filename>，其中<replaceable>mmm</>是用于每一个工作者的序号，序号从 1 开始。
  </para>

<!--==========================orignal english content==========================
  <para>
   The format of the log is:

<synopsis>
<replaceable>client_id</> <replaceable>transaction_no</> <replaceable>time</> <replaceable>script_no</> <replaceable>time_epoch</> <replaceable>time_us</> <optional> <replaceable>schedule_lag</replaceable> </optional>
</synopsis>

   where
   <replaceable>client_id</> indicates which client session ran the transaction,
   <replaceable>transaction_no</> counts how many transactions have been
   run by that session,
   <replaceable>time</> is the total elapsed transaction time in microseconds,
   <replaceable>script_no</> identifies which script file was used (useful when
   multiple scripts were specified with <option>-f</> or <option>-b</>),
   and <replaceable>time_epoch</>/<replaceable>time_us</> are a
   Unix-epoch time stamp and an offset
   in microseconds (suitable for creating an ISO 8601
   time stamp with fractional seconds) showing when
   the transaction completed.
   The <replaceable>schedule_lag</> field is the difference between the
   transaction's scheduled start time, and the time it actually started, in
   microseconds. It is only present when the <option>-&minus;rate</> option is used.
   When both <option>-&minus;rate</> and <option>-&minus;latency-limit</> are used,
   the <replaceable>time</> for a skipped transaction will be reported as
   <literal>skipped</>.
  </para>
____________________________________________________________________________-->
  <para>
   日志的格式是：

<synopsis>
<replaceable>client_id</> <replaceable>transaction_no</> <replaceable>time</> <replaceable>script_no</> <replaceable>time_epoch</> <replaceable>time_us</> <optional> <replaceable>schedule_lag</replaceable> </optional>
</synopsis>

   其中<replaceable>client_id</>指示哪个客户端会话运行了事务，<replaceable>transaction_no</>
   指示该会话运行了多少事务，<replaceable>time</>是以微秒计的总共用掉的事务时间，
   <replaceable>script_no</>标识了要使用哪个脚本文件（当用<option>-f</>或者
   <option>-b</>指定多个脚本时有用），而<replaceable>time_epoch</>/<replaceable>time_us</>
   是一个 Unix 纪元时间戳以及一个显示事务完成时间的以微秒计的偏移量
   （适合于创建一个带有分数秒的 ISO 8601 时间戳）。<replaceable>schedule_lag</>字段
   是事务的预定开始时间和实际开始时间之间的差别，以微秒计。只有使用<option>--rate</>选项时它才存在。当<option>--rate</>和<option>--latency-limit</>同时被使用时， 一个被跳过的事务的<replaceable>time</>会被报告为<literal>skipped</>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Here is a snippet of a log file generated in a single-client run:
<screen>
0 199 2241 0 1175850568 995598
0 200 2465 0 1175850568 998079
0 201 2513 0 1175850569 608
0 202 2038 0 1175850569 2663
</screen>

   Another example with <literal>-&minus;rate=100</>
   and <literal>-&minus;latency-limit=5</> (note the additional
   <replaceable>schedule_lag</> column):
<screen>
0 81 4621 0 1412881037 912698 3005
0 82 6173 0 1412881037 914578 4304
0 83 skipped 0 1412881037 914578 5217
0 83 skipped 0 1412881037 914578 5099
0 83 4722 0 1412881037 916203 3108
0 84 4142 0 1412881037 918023 2333
0 85 2465 0 1412881037 919759 740
</screen>
   In this example, transaction 82 was late, because its latency (6.173 ms) was
   over the 5 ms limit. The next two transactions were skipped, because they
   were already late before they were even started.
  </para>
____________________________________________________________________________-->
  <para>
   以下是在单客户端运行中生成的日志文件的片段：
<screen>
0 199 2241 0 1175850568 995598
0 200 2465 0 1175850568 998079
0 201 2513 0 1175850569 608
0 202 2038 0 1175850569 2663
</screen>
   
   另一个例子使用的是<literal>--rate=100</>以及<literal>--latency-limit=5</>（注意额外的
   <replaceable>schedule_lag</>列）：
<screen>
0 81 4621 0 1412881037 912698 3005
0 82 6173 0 1412881037 914578 4304
0 83 skipped 0 1412881037 914578 5217
0 83 skipped 0 1412881037 914578 5099
0 83 4722 0 1412881037 916203 3108
0 84 4142 0 1412881037 918023 2333
0 85 2465 0 1412881037 919759 740
</screen>
   在这个例子中，事务 82 迟到了，因为它的延迟（6.173 ms）超过了 
   5 ms 限制。接下来的两个事务被跳过，因为它们在开始之前就已经迟到了。
   </para>

<!--==========================orignal english content==========================
  <para>
   When running a long test on hardware that can handle a lot of transactions,
   the log files can become very large.  The <option>-&minus;sampling-rate</> option
   can be used to log only a random sample of transactions.
  </para>
____________________________________________________________________________-->
  <para>
   在能够处理大量事务的硬件上运行一次长时间的测试时，日志文件可能变得非常大。<option>--sampling-rate</>选项能被用来只记录事务的一个随机采样。
  </para>
 </refsect2>

 <refsect2>
<!--==========================orignal english content==========================
  <title>Aggregated Logging</title>
____________________________________________________________________________-->
  <title>聚合的日志记录</title>
  
<!--==========================orignal english content==========================
  <para>
   With the <option>-&minus;aggregate-interval</option> option, a different
   format is used for the log files:

<synopsis>
<replaceable>interval_start</> <replaceable>num_transactions</> <replaceable>sum_latency</> <replaceable>sum_latency_2</> <replaceable>min_latency</> <replaceable>max_latency</> <optional> <replaceable>sum_lag</> <replaceable>sum_lag_2</> <replaceable>min_lag</> <replaceable>max_lag</> <optional> <replaceable>skipped</> </optional> </optional>
</synopsis>

   where
   <replaceable>interval_start</> is the start of the interval (as a Unix
   epoch time stamp),
   <replaceable>num_transactions</> is the number of transactions
   within the interval,
   <replaceable>sum_latency</replaceable> is the sum of the transaction
   latencies within the interval,
   <replaceable>sum_latency_2</replaceable> is the sum of squares of the
   transaction latencies within the interval,
   <replaceable>min_latency</> is the minimum latency within the interval,
   and
   <replaceable>max_latency</> is the maximum latency within the interval.
   The next fields,
   <replaceable>sum_lag</>, <replaceable>sum_lag_2</>, <replaceable>min_lag</>,
   and <replaceable>max_lag</>, are only present if the <option>-&minus;rate</>
   option is used.
   They provide statistics about the time each transaction had to wait for the
   previous one to finish, i.e. the difference between each transaction's
   scheduled start time and the time it actually started.
   The very last field, <replaceable>skipped</>,
   is only present if the <option>-&minus;latency-limit</> option is used, too.
   It counts the number of transactions skipped because they would have
   started too late.
   Each transaction is counted in the interval when it was committed.
  </para>
____________________________________________________________________________-->
  <para>
   通过<option>--aggregate-interval</option>选项，日志文件使用不同的格式：

<synopsis>
<replaceable>interval_start</> <replaceable>num_transactions</> <replaceable>sum_latency</> <replaceable>sum_latency_2</> <replaceable>min_latency</> <replaceable>max_latency</> <optional> <replaceable>sum_lag</> <replaceable>sum_lag_2</> <replaceable>min_lag</> <replaceable>max_lag</> <optional> <replaceable>skipped</> </optional> </optional>
</synopsis>

   其中<replaceable>interval_start</>是区间的开始（作为一个Unix 纪元时间戳），
   <replaceable>num_transactions</>是在区间内的事务数，<replaceable>sum_latency</replaceable>
   是间隔内事务延迟的总和，<replaceable>sum_latency_2</replaceable>是间隔内事务延迟的平方和，
   <replaceable>min_latency</>是区间中的最小延迟，以及<replaceable>max_latency</>
   是区间中的最大延迟。后面字段<replaceable>sum_lag</>、<replaceable>sum_lag_2</>、
   <replaceable>min_lag</>和<replaceable>max_lag</>只有使用了<option>--rate</>选项时才存在。
   它们提供有关每个事务必须等待前一个事务完成的时间的统计信息，
   即每个事务的预定开始时间与实际开始时间之间的差异。
   最后一个字段<replaceable>skipped</>只有在使用<option>--latency-limit</>选项时才会出现。
   它计算跳过的事务数量，因为它们启动的太晚了。每个事务在它提交的时间间隔内计入。
  </para>

<!--==========================orignal english content==========================
  <para>
   Here is some example output:
<screen>
1345828501 5601 1542744 483552416 61 2573
1345828503 7884 1979812 565806736 60 1479
1345828505 7208 1979422 567277552 59 1391
1345828507 7685 1980268 569784714 60 1398
1345828509 7073 1979779 573489941 236 1411
</screen></para>
____________________________________________________________________________-->
  <para>
   这里是一些输出示例：
<screen>
1345828501 5601 1542744 483552416 61 2573
1345828503 7884 1979812 565806736 60 1479
1345828505 7208 1979422 567277552 59 1391
1345828507 7685 1980268 569784714 60 1398
1345828509 7073 1979779 573489941 236 1411
</screen></para>

<!--==========================orignal english content==========================
  <para>
   Notice that while the plain (unaggregated) log file shows which script
   was used for each transaction, the aggregated log does not. Therefore if
   you need per-script data, you need to aggregate the data on your own.
  </para>
____________________________________________________________________________-->
  <para>
   请注意，虽然普通（未聚合）的日志文件显示每个事务使用了哪个脚本，
   但聚合日志则不包含索引。因此如果你需要针对每个脚本的数据，你需要自行聚合数据。
  </para>

 </refsect2>

 <refsect2>
<!--==========================orignal english content==========================
  <title>Per-Statement Latencies</title>
____________________________________________________________________________-->
  <title>每语句延迟</title>

<!--==========================orignal english content==========================
  <para>
   With the <option>-r</> option, <application>pgbench</> collects
   the elapsed transaction time of each statement executed by every
   client.  It then reports an average of those values, referred to
   as the latency for each statement, after the benchmark has finished.
  </para>
____________________________________________________________________________-->
  <para>
   通过<option>-r</>选项，<application>pgbench</>收集每一个客户端执行的每一个语句花费的事务时间。然后在基准完成后，它会报告这些值的平均值，作为每个语句的延迟。
  </para>

<!--==========================orignal english content==========================
  <para>
   For the default script, the output will look similar to this:
<screen>
starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
latency average = 15.844 ms
latency stddev = 2.715 ms
tps = 618.764555 (including connections establishing)
tps = 622.977698 (excluding connections establishing)
script statistics:
 - statement latencies in milliseconds:
        0.002  \set aid random(1, 100000 * :scale)
        0.005  \set bid random(1, 1 * :scale)
        0.002  \set tid random(1, 10 * :scale)
        0.001  \set delta random(-5000, 5000)
        0.326  BEGIN;
        0.603  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
        0.454  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
        5.528  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
        7.335  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
        0.371  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
        1.212  END;
</screen>
  </para>
____________________________________________________________________________-->
  <para>
   对于默认脚本，输出看起来会像这样：
<screen>
starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
latency average = 15.844 ms
latency stddev = 2.715 ms
tps = 618.764555 (including connections establishing)
tps = 622.977698 (excluding connections establishing)
script statistics:
 - statement latencies in milliseconds:
        0.002  \set aid random(1, 100000 * :scale)
        0.005  \set bid random(1, 1 * :scale)
        0.002  \set tid random(1, 10 * :scale)
        0.001  \set delta random(-5000, 5000)
        0.326  BEGIN;
        0.603  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
        0.454  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
        5.528  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
        7.335  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
        0.371  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
        1.212  END;
</screen>
  </para>

<!--==========================orignal english content==========================
  <para>
   If multiple script files are specified, the averages are reported
   separately for each script file.
  </para>
____________________________________________________________________________-->
  <para>
   如果指定了多个脚本文件，会为每一个脚本文件单独报告平均值。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that collecting the additional timing information needed for
   per-statement latency computation adds some overhead.  This will slow
   average execution speed and lower the computed TPS.  The amount
   of slowdown varies significantly depending on platform and hardware.
   Comparing average TPS values with and without latency reporting enabled
   is a good way to measure if the timing overhead is significant.
  </para>
____________________________________________________________________________-->
  <para>
   注意为每个语句的延迟计算收集额外的时间信息会增加一些负荷。这将拖慢平均执行速度并且降低计算出的 TPS。降低的总量会很显著地依赖于平台和硬件。对比使用和不适用延迟报告时的平均 TPS 值是评估时间开销是否明显的好方法。
  </para>
 </refsect2>

 <refsect2>
<!--==========================orignal english content==========================
  <title>Good Practices</title>
____________________________________________________________________________-->
  <title>良好的做法</title>

<!--==========================orignal english content==========================
  <para>
   It is very easy to use <application>pgbench</> to produce completely
   meaningless numbers.  Here are some guidelines to help you get useful
   results.
  </para>
____________________________________________________________________________-->
  <para>
   很容易使用<application>pgbench</>产生完全没有意义的数字。这里有一些指导可以帮你得到有用的结果。
  </para>

<!--==========================orignal english content==========================
  <para>
   In the first place, <emphasis>never</> believe any test that runs
   for only a few seconds.  Use the <option>-t</> or <option>-T</> option
   to make the run last at least a few minutes, so as to average out noise.
   In some cases you could need hours to get numbers that are reproducible.
   It's a good idea to try the test run a few times, to find out if your
   numbers are reproducible or not.
  </para>
____________________________________________________________________________-->
  <para>
   排在第一位的是，<emphasis>永远不要</>相信任何只运行了几秒的测试。使用<option>-t</>或<option>-T</>选项让运行持续至少几分钟，这样可以用平均值去掉噪声。在一些情况中，你可能需要数小时来得到能重现的数字。多运行几次测试是一个好主意，这样可以看看你的数字是不是可以重现。
  </para>

<!--==========================orignal english content==========================
  <para>
   For the default TPC-B-like test scenario, the initialization scale factor
   (<option>-s</>) should be at least as large as the largest number of
   clients you intend to test (<option>-c</>); else you'll mostly be
   measuring update contention.  There are only <option>-s</> rows in
   the <structname>pgbench_branches</> table, and every transaction wants to
   update one of them, so <option>-c</> values in excess of <option>-s</>
   will undoubtedly result in lots of transactions blocked waiting for
   other transactions.
  </para>
____________________________________________________________________________-->
  <para>
   对于默认的类 TPC-B 测试场景，初始化的比例因子（<option>-s</>）应该至少和你想要测试的最大客户端数量一样大（<option>-c</>），否则你将主要在度量更新争夺。在<structname>pgbench_branches</>表中只有<option>-s</>行，并且每个事务都想更新其中之一，因此<option>-c</>值超过<option>-s</>将毫无疑问地导致大量事务被阻塞来等待其他事务。
  </para>

<!--==========================orignal english content==========================
  <para>
   The default test scenario is also quite sensitive to how long it's been
   since the tables were initialized: accumulation of dead rows and dead space
   in the tables changes the results.  To understand the results you must keep
   track of the total number of updates and when vacuuming happens.  If
   autovacuum is enabled it can result in unpredictable changes in measured
   performance.
  </para>
____________________________________________________________________________-->
  <para>
   默认的测试场景也对表被初始化了多久非常敏感：表中死亡行和死亡空间的累积会改变结果。要理解结果，你必须跟踪更新的总数以及何时发生清理。如果开启了自动清理，它可能会在度量的性能上产生不可预估的改变。
  </para>

<!--==========================orignal english content==========================
  <para>
   A limitation of <application>pgbench</> is that it can itself become
   the bottleneck when trying to test a large number of client sessions.
   This can be alleviated by running <application>pgbench</> on a different
   machine from the database server, although low network latency will be
   essential.  It might even be useful to run several <application>pgbench</>
   instances concurrently, on several client machines, against the same
   database server.
  </para>
____________________________________________________________________________-->
  <para>
   <application>pgbench</>的一个限制是在尝试测试大量客户端会话时，它自身可能成为瓶颈。这可以通过在数据库服务器之外的一台机器上运行<application>pgbench</>来缓解，不过必须是具有低网络延迟的机器。甚至可以在多个客户端机器上针对同一个数据库服务器并发地运行多个<application>pgbench</>实例。
  </para>
 </refsect2>
 </refsect1>
</refentry>
