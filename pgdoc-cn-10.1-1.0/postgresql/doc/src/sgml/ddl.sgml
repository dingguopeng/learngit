<!-- doc/src/sgml/ddl.sgml -->

<chapter id="ddl">
 <title>数据定义</title>

 <para>
  本章包含了如何创建用来保存数据的数据库结构。在一个关系型数据库中，原始数据被存储在表中，因此本章的主要工作就是解释如何创建和修改表，以及哪些特性可以控制何种数据会被存储在表中。接着，我们讨论表如何被组织成模式，以及如何将权限分配给表。最后，我们将将简短地介绍其他一些影响数据存储的特性，例如继承、表分区、视图、函数和触发器。
 </para>

 <sect1 id="ddl-basics">
  <title>表基础</title>

  <indexterm zone="ddl-basics">
   <primary>table</primary>
  </indexterm>

  <indexterm>
   <primary>row</primary>
  </indexterm>

  <indexterm>
   <primary>column</primary>
  </indexterm>

  <para>
   关系型数据库中的一个表非常像纸上的一张表：它由行和列组成。列的数量和顺序是固定的，并且每一列拥有一个名字。行的数目是变化的，它反映了在一个给定时刻表中存储的数据量。SQL并不保证表中行的顺序。当一个表被读取时，表中的行将以非特定顺序出现，除非明确地指定需要排序。这些将在<xref linkend="queries">介绍。此外，SQL不会为行分配唯一的标识符，因此在一个表中可能会存在一些完全相同的行。这是SQL之下的数学模型导致的结果，但并不是所期望的。稍后在本章中我们将看到如何处理这种问题。
  </para>

  <para>
   每一列都有一个数据类型。数据类型约束着一组可以分配给列的可能值，并且它为列中存储的数据赋予了语义，这样它可以用于计算。例如，一个被声明为数字类型的列将不会接受任何文本串，而存储在这样一列中的数据可以用来进行数学计算。反过来，一个被声明为字符串类型的列将接受几乎任何一种的数据，它可以进行如字符串连接的操作但不允许进行数学计算。
  </para>

  <para>
   <productname>PostgreSQL</productname>包括了相当多的内建数据类型，可以适用于很多应用。用户也可以定义他们自己的数据类型。大部分内建数据类型有着显而易见的名称和语义，所以我们将它们的详细解释放在<xref linkend="datatype">中。一些常用的数据类型是：用于整数的<type>integer</type>；可以用于分数的<type>numeric</type>；用于字符串的<type>text</type>，用于日期的<type>date</type>，用于一天内时间的<type>time</type>以及可以同时包含日期和时间的<type>timestamp</type>。
  </para>

  <indexterm>
   <primary>table</primary>
   <secondary>creating</secondary>
  </indexterm>

  <para>
   要创建一个表，我们要用到<xref linkend="sql-createtable">命令。在这个命令中 我们需要为新表至少指定一个名字、列的名字及数据类型。例如：
<programlisting>
CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);
</programlisting>
   这将创建一个名为<literal>my_first_table</literal>的表，它拥有两个列。第一个列名为<literal>first_column</literal>且数据类型为<type>text</type>；第二个列名为<literal>second_column</literal>且数据类型为<type>integer</type>。表和列的名字遵循<xref linkend="sql-syntax-identifiers">中解释的标识符语法。类型名称通常也是标识符，但是也有些例外。注意列的列表由逗号分隔并被圆括号包围。
  </para>

  <para>
   当然，前面的例子是非常不自然的。通常，我们为表和列赋予的名称都会表明它们存储着什么类别的数据。因此让我们再看一个更现实的例子：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);
</programlisting>
   （<type>numeric</type>类型能够存储小数部分，典型的例子是金额。）
  </para>

  <tip>
   <para>
    当我们创建很多相关的表时，最好为表和列选择一致的命名模式。例如，一种选择是用单数或复数名词作为表名，每一种都受到一些理论家支持。
   </para>
  </tip>

  <para>
   一个表能够拥有的列的数据是有限的，根据列的类型，这个限制介于250和1600之间。但是，极少会定义一个接近这个限制的表，即便有也是一个值得商榷的设计。
  </para>

  <indexterm>
   <primary>table</primary>
   <secondary>removing</secondary>
  </indexterm>

  <para>
   如果我们不再需要一个表，我们可以通过使用<xref
   linkend="sql-droptable">命令来移除它。例如：
<programlisting>
DROP TABLE my_first_table;
DROP TABLE products;
</programlisting>
   尝试移除一个不存在的表会引起错误。然而，在SQL脚本中在创建每个表之前无条件地尝试移除它的做法是很常见的，即使发生错误也会忽略之，因此这样的脚本可以在表存在和不存在时都工作得很好（如果你喜欢，可以使用<literal>DROP TABLE IF EXISTS</>变体来防止出现错误消息，但这并非标准SQL）。
  </para>

  <para>
   如果我们需要修改一个已经存在的表，请参考本章稍后的<xref
   linkend="ddl-alter">。
  </para>

  <para>
   利用到目前为止所讨论的工具，我们可以创建一个全功能的表。本章的后续部分将集中于为表定义增加特性来保证数据完整性、安全性或方便。如果你希望现在就去填充你的表，你可以跳过这些直接去<xref linkend="dml">。
  </para>
 </sect1>

 <sect1 id="ddl-default">
  <title>默认值</title>

  <indexterm zone="ddl-default">
   <primary>default value</primary>
  </indexterm>

  <para>
   一个列可以被分配一个默认值。当一个新行被创建且没有为某些列指定值时，这些列将会被它们相应的默认值填充。一个数据操纵命令也可以显式地要求一个列被置为它的默认值，而不需要知道这个值到底是什么（数据操纵命令详见<xref linkend="dml">）。
  </para>

  <para>
   <indexterm><primary>null value</primary><secondary>default value</secondary></indexterm>
   如果没有显式指定默认值，则默认值是空值。这是合理的，因为空值表示未知数据。
  </para>

  <para>
   在一个表定义中，默认值被列在列的数据类型之后。例如：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>DEFAULT 9.99</emphasis>
);
</programlisting>
  </para>

  <para>
   默认值可以是一个表达式，它将在任何需要插入默认值的时候被实时计算（<emphasis>不</emphasis>是表创建时）。一个常见的例子是为一个<type>timestamp</type>列指定默认值为<literal>CURRENT_TIMESTAMP</>，这样它将得到行被插入时的时间。另一个常见的例子是为每一行生成一个<quote>序列号</> 。这在<productname>PostgreSQL</productname>可以按照如下方式实现：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>DEFAULT nextval('products_product_no_seq')</emphasis>,
    ...
);
</programlisting>
   这里<literal>nextval()</>函数从一个<firstterm>序列对象</firstterm><xref linkend="functions-sequence">）。还有一种特别的速写：
<programlisting>
CREATE TABLE products (
    product_no <emphasis>SERIAL</emphasis>,
    ...
);
</programlisting>
   <literal>SERIAL</>速写将在<xref
   linkend="datatype-serial">进一步讨论。
  </para>
 </sect1>

 <sect1 id="ddl-constraints">
  <title>约束</title>

  <indexterm zone="ddl-constraints">
   <primary>constraint</primary>
  </indexterm>

  <para>
   数据类型是一种限制能够存储在表中数据类别的方法。但是对于很多应用来说，它们提供的约束太粗糙。例如，一个包含产品价格的列应该只接受正值。但是没有任何一种标准数据类型只接受正值。另一个问题是我们可能需要根据其他列或行来约束一个列中的数据。例如，在一个包含产品信息的表中，对于每个产品编号应该只有一行。
  </para>

  <para>
   到目前为止，SQL允许我们在列和表上定义约束。约束让我们能够根据我们的愿望来控制表中的数据。如果一个用户试图在一个列中保存违反一个约束的数据，一个错误会被抛出。即便是这个值来自于默认值定义，这个规则也同样适用。
  </para>

  <sect2 id="ddl-constraints-check-constraints">
   <title>检查约束</title>

   <indexterm>
    <primary>check constraint</primary>
   </indexterm>

   <indexterm>
    <primary>constraint</primary>
    <secondary>check</secondary>
   </indexterm>

   <para>
    一个检查约束是最普通的约束类型。它允许我们指定一个特定列中的值必须要满足一个布尔表达式。例如，为了要求正值的产品价格，我们可以使用：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CHECK (price &gt; 0)</emphasis>
);
</programlisting>
   </para>

   <para>
    如你所见，约束定义就和默认值定义一样跟在数据类型之后。默认值和约束之间的顺序没有影响。一个检查约束有关键字<literal>CHECK</literal>以及其后的包围在圆括号中的表达式组成。检查约束表达式应该涉及到被约束的列，否则该约束也没什么实际意义。
   </para>

   <indexterm>
    <primary>constraint</primary>
    <secondary>name</secondary>
   </indexterm>

   <para>
    我们也可以给与约束一个独立的名称。这会使得错误消息更为清晰，同时也允许我们在需要更改约束时能引用它。语法为：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CONSTRAINT positive_price</emphasis> CHECK (price &gt; 0)
);
</programlisting>
    要指定一个命名的约束，请在约束名称标识符前使用关键词<literal>CONSTRAINT</literal>，然后把约束定义放在标识符之后（如果没有以这种方式指定一个约束名称，系统将会为我们选择一个）。
   </para>

   <para>
    一个检查约束也可以引用多个列。例如我们存储一个普通价格和一个打折后的价格，而我们希望保证打折后的价格低于普通价格：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric CHECK (discounted_price &gt; 0),
    <emphasis>CHECK (price &gt; discounted_price)</emphasis>
);
</programlisting>
   </para>

   <para>
    前两个约束看起来很相似。第三个则使用了一种新语法。它并没有依附在一个特定的列，而是作为一个独立的项出现在逗号分隔的列列表中。列定义和这种约束定义可以以混合的顺序出现在列表中。
   </para>

   <para>
    我们将前两个约束称为列约束，而第三个约束为表约束，因为它独立于任何一个列定义。列约束也可以写成表约束，但反过来不行，因为一个列约束只能引用它所依附的那一个列（<productname>PostgreSQL</productname>并不强制要求这个规则，但是如果我们希望表定义能够在其他数据库系统中工作，那就应该遵循它）。上述例子也可以写成：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    CHECK (price &gt; discounted_price)
);
</programlisting>
    甚至是：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)
);
</programlisting>
    这只是个人偏好的问题。
   </para>

   <para>
    表约束也可以用列约束相同的方法来指定名称：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    <emphasis>CONSTRAINT valid_discount</> CHECK (price &gt; discounted_price)
);
</programlisting>
   </para>

   <indexterm>
    <primary>null value</primary>
    <secondary sortas="check constraints">with check constraints</secondary>
   </indexterm>

   <para>
    需要注意的是，一个检查约束在其检查表达式值为真或空值时被满足。因为当任何操作数为空时大部分表达式将计算为空值，所以它们不会阻止被约束列中的控制。为了保证一个列不包含控制，可以使用下一节中的非空约束。
   </para>
  </sect2>

  <sect2>
   <title>非空约束</title>

   <indexterm>
    <primary>not-null constraint</primary>
   </indexterm>

   <indexterm>
    <primary>constraint</primary>
    <secondary>NOT NULL</secondary>
   </indexterm>

   <para>
    一个非空约束仅仅指定一个列中不会有空值。语法例子：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>NOT NULL</emphasis>,
    name text <emphasis>NOT NULL</emphasis>,
    price numeric
);
</programlisting>
   </para>

   <para>
    一个非空约束总是被写成一个列约束。一个非空约束等价于创建一个检查约束<literal>CHECK (<replaceable>column_name</replaceable>
    IS NOT NULL)</literal>，但在<productname>PostgreSQL</productname>中创建一个显式的非空约束更高效。这种方式创建的非空约束的缺点是我们无法为它给予一个显式的名称。
   </para>

   <para>
    当然，一个列可以有多于一个的约束，只需要将这些约束一个接一个写出：
<programlisting>
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price &gt; 0)
);
</programlisting>
    约束的顺序没有关系，因为并不需要决定约束被检查的顺序。
   </para>

   <para>
    <literal>NOT NULL</literal>约束有一个相反的情况：<literal>NULL</literal>约束。这并不意味着该列必须为空，进而肯定是无用的。相反，它仅仅选择了列可能为空的默认行为。SQL标准中并不存在<literal>NULL</literal>约束，因此它不能被用于可移植的应用中（<productname>PostgreSQL</productname>中加入它是为了和某些其他数据库系统兼容）。但是某些用户喜欢它，因为它使得在一个脚本文件中可以很容易的进行约束切换。例如，初始时我们可以：
<programlisting>
CREATE TABLE products (
    product_no integer NULL,
    name text NULL,
    price numeric NULL
);
</programlisting>
    然后可以在需要的地方插入<literal>NOT</literal>关键词。
   </para>

   <tip>
    <para>
     在大部分数据库中多数列应该被标记为非空。
    </para>
   </tip>
  </sect2>

  <sect2 id="ddl-constraints-unique-constraints">
   <title>唯一约束</title>

   <indexterm>
    <primary>unique constraint</primary>
   </indexterm>

   <indexterm>
    <primary>constraint</primary>
    <secondary>unique</secondary>
   </indexterm>

   <para>
    唯一约束保证\在一列中或者一组列中保存的数据在表中所有行间是唯一的。写成一个列约束的语法是：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>UNIQUE</emphasis>,
    name text,
    price numeric
);
</programlisting>
    写成一个表约束的语法是：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    <emphasis>UNIQUE (product_no)</emphasis>
);
</programlisting>
   </para>

   <para>
    要为一组列定义一个唯一约束，把它写作一个表级约束，列名用逗号分隔：
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>UNIQUE (a, c)</emphasis>
);
</programlisting>
    这指定这些列的组合值在整个表的范围内是唯一的，但其中任意一列的值并不需要是（一般也不是）唯一的。
   </para>

   <para>
    我们可以通常的方式为一个唯一索引命名：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>CONSTRAINT must_be_different</emphasis> UNIQUE,
    name text,
    price numeric
);
</programlisting>
   </para>

   <para>
    增加一个唯一约束会在约束中列出的列或列组上自动创建一个唯一B-tree索引。只覆盖某些行的唯一性限制不能被写为一个唯一约束，但可以通过创建一个唯一的<link linkend="indexes-partial">部分索引</link>来强制这种限制。
   </para>

   <indexterm>
    <primary>null value</primary>
    <secondary sortas="unique constraints">with unique constraints</secondary>
   </indexterm>

   <para>
    通常，如果表中有超过一行在约束所包括列上的值相同，将会违反唯一约束。但是在这种比较中，两个空值被认为是不同的。这意味着即便存在一个唯一约束，也可以存储多个在至少一个被约束列中包含空值的行。这种行为符合SQL标准，但我们听说一些其他SQL数据库可能不遵循这个规则。所以在开发需要可移植的应用时应注意这一点。
   </para>
  </sect2>

  <sect2 id="ddl-constraints-primary-keys">
   <title>主键</title>

   <indexterm>
    <primary>primary key</primary>
   </indexterm>

   <indexterm>
    <primary>constraint</primary>
    <secondary>primary key</secondary>
   </indexterm>

   <para>
    一个主键约束表示可以用作表中行的唯一标识符的一个列或者一组列。这要求那些值都是唯一的并且非空。因此，下面的两个表定义接受相同的数据：
<programlisting>
CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);
</programlisting>

<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>PRIMARY KEY</emphasis>,
    name text,
    price numeric
);
</programlisting>
   </para>

   <para>
    主键也可以包含多于一个列，其语法和唯一约束相似：
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>PRIMARY KEY (a, c)</emphasis>
);
</programlisting>
   </para>

   <para>
    增加一个主键将自动在主键中列出的列或列组上创建一个唯一B-tree索引。并且会强制这些列被标记为<literal>NOT NULL</>。
   </para>

   <para>
    一个表最多只能有一个主键（可以有任意数量的唯一和非空约束，它们可以达到和主键几乎一样的功能，但只能有一个被标识为主键）。关系数据库理论要求每一个表都要有一个主键。但<productname>PostgreSQL</productname>中并未强制要求这一点，但是最好能够遵循它。
   </para>
   
   <para>
    主键对于文档和客户端应用都是有用的。例如，一个允许修改行值的 GUI 应用可能需要知道一个表的主键，以便能唯一地标识行。如果定义了主键，数据库系统也有多种方法来利用主键。例如，主键定义了外键要引用的默认目标列。
   </para>
  </sect2>

  <sect2 id="ddl-constraints-fk">
   <title>外键</title>

   <indexterm>
    <primary>foreign key</primary>
   </indexterm>

   <indexterm>
    <primary>constraint</primary>
    <secondary>foreign key</secondary>
   </indexterm>

   <indexterm>
    <primary>referential integrity</primary>
   </indexterm>

   <para>
    一个外键约束指定一列（或一组列）中的值必须匹配出现在另一个表中某些行的值。我们说这维持了两个关联表之间的<firstterm>引用完整性</firstterm>。
   </para>

   <para>
    例如我们有一个使用过多次的产品表：
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
</programlisting>
    让我们假设我们还有一个存储这些产品订单的表。我们希望保证订单表中只包含真正存在的产品的订单。因此我们在订单表中定义一个引用产品表的外键约束：
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products (product_no)</emphasis>,
    quantity integer
);
</programlisting>
    现在就不可能创建包含不存在于产品表中的<structfield>product_no</structfield>值（非空）的订单。
   </para>

   <para>
    我们说在这种情况下，订单表是<firstterm>引用</firstterm>表而产品表是<firstterm>被引用</firstterm>表。相应地，也有引用和被引用列的说法。
   </para>

   <para>
    我们也可以把上述命令简写为：
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products</emphasis>,
    quantity integer
);
</programlisting>
    因为如果缺少列的列表，则被引用表的主键将被用作被引用列。
   </para>

   <para>
    一个外键也可以约束和引用一组列。照例，它需要被写成表约束的形式。下面是一个例子：
<programlisting>
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  <emphasis>FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)</emphasis>
);
</programlisting>
    当然，被约束列的数量和类型应该匹配被引用列的数量和类型。
   </para>

   <para>
    按照前面的方式，我们可以为一个外键约束命名。
   </para>

   <para>
    一个表可以有超过一个的外键约束。这被用于实现表之间的多对多关系。例如我们有关于产品和订单的表，但我们现在希望一个订单能包含多种产品（这在上面的结构中是不允许的）。我们可以使用这种表结构：
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
    注意在最后一个表中主键和外键之间有重叠。
   </para>

   <indexterm>
    <primary>CASCADE</primary>
    <secondary>foreign key action</secondary>
   </indexterm>

   <indexterm>
    <primary>RESTRICT</primary>
    <secondary>foreign key action</secondary>
   </indexterm>

   <para>
    我们知道外键不允许创建与任何产品都不相关的订单。但如果一个产品在一个引用它的订单创建之后被移除会发生什么？SQL允许我们处理这种情况。直观上，我们有几种选项：
    <itemizedlist spacing="compact">
     <listitem><para>不允许删除一个被引用的产品</para></listitem>
     <listitem><para>同时也删除引用产品的订单</para></listitem>
     <listitem><para>其他？</para></listitem>
    </itemizedlist>
   </para>

   <para>
    为了说明这些，让我们在上面的多对多关系例子中实现下面的策略：当某人希望移除一个仍然被一个订单引用（通过<literal>order_items</literal>）的产品时 ，我们组织它。如果某人移除一个订单，订单项也同时被移除：
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products <emphasis>ON DELETE RESTRICT</emphasis>,
    order_id integer REFERENCES orders <emphasis>ON DELETE CASCADE</emphasis>,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
   </para>

   <para>
    限制删除或者级联删除是两种最常见的选项。<literal>RESTRICT</literal>阻止删除一个被引用的行。<literal>NO ACTION</literal>表示在约束被检察时如果有任何引用行存在，则会抛出一个错误，这是我们没有指定任何东西时的默认行为（这两种选择的本质不同在于<literal>NO ACTION</literal>允许检查被推迟到事务的最后，而<literal>RESTRICT</literal>则不会）。<literal>CASCADE</>指定当一个被引用行被删除后，引用它的行也应该被自动删除。还有其他两种选项：<literal>SET NULL</literal>和<literal>SET DEFAULT</literal>。这些将导致在被引用行被删除后，引用行中的引用列被置为空值或它们的默认值。注意这些并不会是我们免于遵守任何约束。例如，如果一个动作指定了<literal>SET DEFAULT</literal>，但是默认值不满足外键约束，操作将会失败。
   </para>

   <para>
    与<literal>ON DELETE</literal>相似，同样有<literal>ON UPDATE</literal>可以用在一个被引用列被修改（更新）的情况，可选的动作相同。在这种情况下，<literal>CASCADE</>意味着被引用列的更新值应该被复制到引用行中。
   </para>

   <para>
    正常情况下，如果一个引用行的任意一个引用列都为空，则它不需要满足外键约束。如果在外键定义中加入了<literal>MATCH FULL</>，一个引用行只有在它的所有引用列为空时才不需要满足外键约束（因此空和非空值的混合肯定会导致<literal>MATCH FULL</>约束失败）。如果不希望引用行能够避开外键约束，将引用行声明为<literal>NOT NULL</>。
   </para>

   <para>
    一个外键所引用的列必须是一个主键或者被唯一约束所限制。这意味着被引用列总是拥有一个索引（位于主键或唯一约束之下的索引），因此在其上进行的一个引用行是否匹配的检查将会很高效。由于从被引用表中<command>DELETE</command>一行或者<command>UPDATE</command>一个被引用列将要求对引用表进行扫描以得到匹配旧值的行，在引用列上建立合适的索引也会大有益处。由于这种做法并不是必须的，而且创建索引也有很多种选择，所以外键约束的定义并不会自动在引用列上创建索引。
   </para>

   <para>
    更多关于更新和删除数据的信息请见<xref
    linkend="dml">。外键约束的语法描述请参考<xref linkend="sql-createtable">。
   </para>
  </sect2>

  <sect2 id="ddl-constraints-exclusion">
   <title>排他约束</title>

   <indexterm>
    <primary>exclusion constraint</primary>
   </indexterm>

   <indexterm>
    <primary>constraint</primary>
    <secondary>exclusion</secondary>
   </indexterm>

   <para>
    排他约束保证如果将任何两行的指定列或表达式使用指定操作符进行比较，至少其中一个操作符比较将会返回否或空值。语法是：
<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
   </para>

   <para>
    详见<link linkend="SQL-CREATETABLE-EXCLUDE"><command>CREATE
    TABLE ... CONSTRAINT ... EXCLUDE</></link>。
   </para>

   <para>
    增加一个排他约束将在约束声明所指定的类型上自动创建索引。
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-system-columns">
  <title>系统列</title>

  <para>
   每一个表都拥有一些由系统隐式定义的<firstterm>系统列</>。因此，这些列的名字不能像用户定义的列一样使用（注意这种限制与名称是否为关键词没有关系，即便用引号限定一个名称也无法绕过这种限制）。 事实上用户不需要关心这些列，只需要知道它们存在即可。
  </para>

  <indexterm>
   <primary>column</primary>
   <secondary>system column</secondary>
  </indexterm>

  <variablelist>
   <varlistentry>
    <term><structfield>oid</></term>
    <listitem>
     <para>
      <indexterm>
       <primary>OID</primary>
       <secondary>column</secondary>
      </indexterm>
      一行的对象标识符（对象ID）。该列只有在表使用<literal>WITH OIDS</literal>创建时或者<xref linkend="guc-default-with-oids">配置变量被设置时才存在。该列的类型为<type>oid</type>（与列名一致），该类型详见<xref linkend="datatype-oid">。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>tableoid</></term>
    <listitem>
     <indexterm>
      <primary>tableoid</primary>
     </indexterm>

     <para>
      包含这一行的表的OID。该列是特别为从继承层次（见<xref linkend="ddl-inherit">）中选择的查询而准备，因为如果没有它将很难知道一行来自于哪个表。<structfield>tableoid</structfield>可以与<structname>pg_class</structname>的<structfield>oid</structfield>列进行连接来获得表的名称。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>xmin</></term>
    <listitem>
     <indexterm>
      <primary>xmin</primary>
     </indexterm>

     <para>
      插入该行版本的事务身份（事务ID）。一个行版本是一个行的一个特别版本，对一个逻辑行的每一次更新都将创建一个新的行版本。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>cmin</></term>
    <listitem>
     <indexterm>
      <primary>cmin</primary>
     </indexterm>

     <para>
      插入事务中的命令标识符（从0开始）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>xmax</></term>
    <listitem>
     <indexterm>
      <primary>xmax</primary>
     </indexterm>

     <para>
      删除事务的身份（事务ID），对于未删除的行版本为0。对于一个可见的行版本，该列值也可能为非零。这通常表示删除事务还没有提交，或者一个删除尝试被回滚。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>cmax</></term>
    <listitem>
     <indexterm>
      <primary>cmax</primary>
     </indexterm>

     <para>
      删除事务中的命令标识符，或者为0。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>ctid</></term>
    <listitem>
     <indexterm>
      <primary>ctid</primary>
     </indexterm>

     <para>
      行版本在其表中的物理位置。注意尽管<structfield>ctid</structfield>可以被用来非常快速地定位行版本，但是一个行的<structfield>ctid</structfield>会在被更新或者被<command>VACUUM FULL</>移动时改变。因此，<structfield>ctid</structfield>不能作为一个长期行标识符。OID或者最好是一个用户定义的序列号才应该被用来标识逻辑行。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

   <para>
    OID是32位量，它从一个服务于整个集簇的计数器分配而来。在一个大型的或者历时长久的数据库中，该计数器有可能会出现绕回。因此，不要总是假设OID是唯一的，除非你采取了措施来保证。如果需要在一个表中标识行，推荐使用一个序列生成器。然而，OID也可以被使用，但是是要采取一些额外的预防措施：

    <itemizedlist>
     <listitem>
      <para>
       如果要将OID用来标识行，应该在OID列上创建一个唯一约束。当这样一个唯一约束（或唯一索引）存在时，系统会注意不生成匹配现有行的OID（当然，这只有在表的航数目少于2<superscript>32</>（40亿）时才成立。并且在实践中表的尺寸最好远比这个值小，否则将会牺牲性能）。
      </para>
     </listitem>
     <listitem>
      <para>
       绝不要认为OID在表之间也是唯一的，使用<structfield>tableoid</>和行OID的组合来作为数据库范围内的标识符。
      </para>
     </listitem>
     <listitem>
      <para>
       当然，问题中的表都必须是用<literal>WITH OIDS</literal>创建。在<productname>PostgreSQL</productname> 8.1中，<literal>WITHOUT OIDS</>是默认形式。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    事务标识符也是32位量。在一个历时长久的数据库中事务ID同样会绕回。但如果采取适当的维护过程，这不会是一个致命的问题，详见<xref linkend="maintenance">。但是，长期（超过10亿个事务）依赖事务ID的唯一性是不明智的。
   </para>

   <para>
    命令标识符也是32位量。这对一个事务中包含的<acronym>SQL</acronym>命令设置了一个硬极限：
    2<superscript>32</>（40亿）。在实践中，该限制并不是问题 &mdash; 注意该限制只是针对<acronym>SQL</acronym>命令的数目而不是被处理的行数。同样，只有真正
    修改了数据库内容的命令才会消耗一个命令标识符。
   </para>
 </sect1>

 <sect1 id="ddl-alter">
  <title>修改表</title>

  <indexterm zone="ddl-alter">
   <primary>table</primary>
   <secondary>modifying</secondary>
  </indexterm>

  <para>
   当我们已经创建了一个表并意识到犯了一个错误或者应用需求发生改变时，我们可以移除表并重新创建它。但如果表中已经被填充数据或者被其他数据库对象引用（例如有一个外键约束），这种做法就显得很不方便。因此，<productname>PostgreSQL</productname>提供了一族命令来对已有的表进行修改。注意这和修改表中所包含的数据是不同的，这里要做的是对表的定义或者说结构进行修改。
  </para>

  <para>
   利用这些命令，我们可以：
   <itemizedlist spacing="compact">
    <listitem>
     <para>增加列</para>
    </listitem>
    <listitem>
     <para>移除列</para>
    </listitem>
    <listitem>
     <para>增加约束</para>
    </listitem>
    <listitem>
     <para>移除约束</para>
    </listitem>
    <listitem>
     <para>修改默认值</para>
    </listitem>
    <listitem>
     <para>修改列数据类型</para>
    </listitem>
    <listitem>
     <para>重命名列</para>
    </listitem>
    <listitem>
     <para>重命名表</para>
    </listitem>
   </itemizedlist>

   所有这些动作都由<xref linkend="sql-altertable">命令执行，其参考页面中包含更详细的信息。
  </para>

  <sect2 id="ddl-alter-adding-a-column">
   <title>增加列</title>

   <indexterm>
    <primary>column</primary>
    <secondary>adding</secondary>
   </indexterm>

   <para>
    要增加一个列，可以使用这样的命令：
<programlisting>
ALTER TABLE products ADD COLUMN description text;
</programlisting>
    新列将被默认值所填充（如果没有指定<literal>DEFAULT</>子句，则会填充空值）。
   </para>

   <para>
    也可以同时为列定义约束，语法：
<programlisting>
ALTER TABLE products ADD COLUMN description text CHECK (description &lt;&gt; '');
</programlisting>
    事实上<command>CREATE TABLE</>中关于一列的描述都可以应用在这里。记住不管怎样，默认值必须满足给定的约束，否则<literal>ADD</>将会失败。也可以先将新列正确地填充好，然后再增加约束（见后文）。
   </para>

  <tip>
   <para>
    增加一个带默认值的列需要更新表中的每一行（来存储新列值）。然而，如果不指定默认值，<productname>PostgreSQL</productname>可以避免物理更新。因此如果我们准备向列中填充的值大多是非默认值，最好是增加列的时候不指定默认值，增加列后用<command>UPDATE</>填充正确的数据并且增加所需要的默认值约束。   </para>
  </tip>
  </sect2>

  <sect2 id="ddl-alter-removing-a-column">
   <title>移除列</title>

   <indexterm>
    <primary>column</primary>
    <secondary>removing</secondary>
   </indexterm>

   <para>
    为了移除一个列，使用如下的命令：
<programlisting>
ALTER TABLE products DROP COLUMN description;
</programlisting>
    列中的数据将会消失。涉及到该列的表约束也会被移除。然而，如果该列被另一个表的外键所引用，<productname>PostgreSQL</productname>不会安静地移除该约束。我们可以通过增加<literal>CASCADE</>来授权移除任何依赖于被删除列的所有东西：
<programlisting>
ALTER TABLE products DROP COLUMN description CASCADE;
</programlisting>
    关于这个操作背后的一般性机制请见<xref linkend="ddl-depend">。
   </para>
  </sect2>

  <sect2 id="ddl-alter-adding-a-constraint">
   <title>增加约束</title>

   <indexterm>
    <primary>constraint</primary>
    <secondary>adding</secondary>
   </indexterm>

   <para>
    为了增加一个约束，可以使用表约束的语法，例如：
<programlisting>
ALTER TABLE products ADD CHECK (name &lt;&gt; '');
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
</programlisting>
    要增加一个不能写成表约束的非空约束，可使用语法：
<programlisting>
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
</programlisting>
   </para>

   <para>
    该约束会立即被检查，所以表中的数据必须在约束被增加之前就已经符合约束。
   </para>
  </sect2>

  <sect2 id="ddl-alter-removing-a-constraint">
   <title>移除约束</title>

   <indexterm>
    <primary>constraint</primary>
    <secondary>removing</secondary>
   </indexterm>

   <para>
    为了移除一个约束首先需要知道它的名称。如果在创建时已经给它指定了名称，那么事情就变得很容易。否则约束的名称是由系统生成的，我们必须先找出这个名称。<application>psql</application>的命令<literal>\d
    <replaceable>表名</replaceable></literal>将会对此有所帮助，其他接口也会提供方法来查看表的细节。因此命令是：
<programlisting>
ALTER TABLE products DROP CONSTRAINT some_name;
</programlisting>
    （如果处理的是自动生成的约束名称，如<literal>$2</>，别忘了用双引号使它变成一个合法的标识符。）
   </para>

   <para>
    和移除一个列相似，如果需要移除一个被某些别的东西依赖的约束，也需要加上<literal>CASCADE</>。一个例子是一个外键约束依赖于被引用列上的一个唯一或者主键约束。
   </para>

   <para>
    这对除了非空约束之外的所有约束类型都一样有效。为了移除一个非空约束可以用：
<programlisting>
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
</programlisting>
    （回忆一下，非空约束是没有名称的，所以不能用第一种方式。）
   </para>
  </sect2>

  <sect2>
   <title>更改列的默认值</title>

   <indexterm>
    <primary>default value</primary>
    <secondary>changing</secondary>
   </indexterm>

   <para>
    要为一个列设置一个新默认值，使用命令：
<programlisting>
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
</programlisting>
    注意这不会影响任何表中已经存在的行，它只是为未来的<command>INSERT</>命令改变了默认值。
   </para>

   <para>
    要移除任何默认值，使用：
<programlisting>
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
</programlisting>
    这等同于将默认值设置为空值。相应的，试图删除一个未被定义的默认值并不会引发错误，因为默认值已经被隐式地设置为空值。
   </para>
  </sect2>

  <sect2>
   <title>修改列的数据类型</title>

   <indexterm>
    <primary>column data type</primary>
    <secondary>changing</secondary>
   </indexterm>

   <para>
    为了将一个列转换为一种不同的数据类型，使用如下命令：
<programlisting>
ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
</programlisting>
    只有当列中的每一个项都能通过一个隐式造型转换为新的类型时该操作才能成功。如果需要一种更复杂的转换，应该加上一个<literal>USING</>子句来指定应该如何把旧值转换为新值。
   </para>

   <para>
    <productname>PostgreSQL</>将尝试把列的默认值转换为新类型，其他涉及到该列的任何约束也是一样。但是这些转换可能失败或者产生奇特的结果。因此最好在修改类型之前先删除该列上所有的约束，然后在修改完类型后重新加上相应修改过的约束。
   </para>
  </sect2>

  <sect2>
   <title>重命名列</title>

   <indexterm>
    <primary>column</primary>
    <secondary>renaming</secondary>
   </indexterm>

   <para>
    要重命名一个列：
<programlisting>
ALTER TABLE products RENAME COLUMN product_no TO product_number;
</programlisting>
   </para>
  </sect2>

  <sect2>
   <title>重命名表</title>

   <indexterm>
    <primary>table</primary>
    <secondary>renaming</secondary>
   </indexterm>

   <para>
    要重命名一个表：
<programlisting>
ALTER TABLE products RENAME TO items;
</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-priv">
  <title>权限</title>

  <indexterm zone="ddl-priv">
   <primary>privilege</primary>
  </indexterm>

  <indexterm>
   <primary>permission</primary>
   <see>privilege</see>
  </indexterm>

  <indexterm zone="ddl-priv">
   <primary>owner</primary>
  </indexterm>

  <indexterm zone="ddl-priv">
   <primary>GRANT</primary>
  </indexterm>

  <indexterm zone="ddl-priv">
   <primary>REVOKE</primary>
  </indexterm>

  <para>
   一旦一个对象被创建，它会被分配一个所有者。所有者通常是执行创建语句的角色。对于大部分类型的对象，初始状态下只有所有者（或者超级用户）能够对该对象做任何事情。为了允许其他角色使用它，必须分配<firstterm>权限</firstterm>。
  </para>

  <para>
   有多种不同的权限：<literal>SELECT</>、<literal>INSERT</>、<literal>UPDATE</>、<literal>DELETE</>、<literal>TRUNCATE</>、<literal>REFERENCES</>、<literal>TRIGGER</>、<literal>CREATE</>、<literal>CONNECT</>、<literal>TEMPORARY</>、<literal>EXECUTE</>以及<literal>USAGE</>。可以应用于一个特定对象的权限随着对象的类型（表、函数等）而不同。<productname>PostgreSQL</productname>所支持的不同类型的完整权限信息请参考<xref linkend="sql-grant">。下面的章节将简单介绍如何使用这些权限。
  </para>

  <para>
   修改或销毁一个对象的权力通常是只有所有者才有的权限。
  </para>

  <para>
   一个对象可以通过该对象类型相应的<command>ALTER</command>命令来重新分配所有者，例如<xref linkend="sql-altertable">。超级用户总是可以做到这点，普通角色只有同时是对象的当前所有者（或者是拥有角色的一个成员）以及新拥有角色的一个成员时才能做同样的事。
  </para>

  <para>
   要分配权限，可以使用<command>GRANT</command>命令。例如，如果<literal>joe</literal>是一个已有角色，而<literal>accounts</literal>是一个已有表，更新该表的权限可以按如下方式授权：
<programlisting>
GRANT UPDATE ON accounts TO joe;
</programlisting>
   用<literal>ALL</literal>取代特定权限会把与对象类型相关的所有权限全部授权。
  </para>

  <para>
   一个特殊的名为<literal>PUBLIC</literal>的<quote>角色</quote>可以用来向系统中的每一个角色授予一个权限。同时，在数据库中有很多用户时可以设置<quote>组</>角色来帮助管理权限。详见<xref linkend="user-manag">。
  </para>

  <para>
   为了撤销一个权限，使用<command>REVOKE</command>命令：
<programlisting>
REVOKE ALL ON accounts FROM PUBLIC;
</programlisting>
   对象拥有者的特殊权限（即执行<command>DROP</>、<command>GRANT</>、<command>REVOKE</>等的权力）总是隐式地属于拥有者，并且不能被授予或撤销。但是对象拥有者可以选择撤销他们自己的普通权限，例如把一个表变得对他们自己和其他人只读。
  </para>

  <para>
   一般情况下，只有对象拥有者（或者超级用户）可以授予或撤销一个对象上的权限。但是可以在授予权限时使用<quote>with grant option</>来允许接收人将权限转授给其他人。如果后来授予选项被撤销，则所有从接收人那里获得的权限（直接或者通过授权链获得）都将被撤销。更多详情请见<xref linkend="sql-grant">和<xref linkend="sql-revoke">参考页。
  </para>
 </sect1>
 
 <sect1 id="ddl-rowsecurity">
  <title>行安全性策略</title>

  <indexterm zone="ddl-rowsecurity">
   <primary>row-level security</primary>
  </indexterm>

  <indexterm zone="ddl-rowsecurity">
   <primary>policy</primary>
  </indexterm>

  <para>
   除可以通过<xref linkend="sql-grant">使用 SQL 标准的
   <link linkend="ddl-priv">特权系统</link>之外，表还可以具有
   <firstterm>行安全性策略</>，它针对每一个用户限制哪些行可以
   被普通的查询返回或者可以被数据修改命令插入、更新或删除。这种
   特性也被称为<firstterm>行级安全性</>。默认情况下，表不具有
   任何策略，这样用户根据 SQL 特权系统具有对表的访问特权，对于
   查询或更新来说其中所有的行都是平等的。
  </para>

  <para>
   当在一个表上启用行安全性时（使用
   <link linkend="sql-altertable">ALTER TABLE ... ENABLE ROW LEVEL
   SECURITY</>），所有对该表选择行或者修改行的普通访问都必须被一条
   行安全性策略所允许（不过，表的拥有者通常不服从行安全性策略）。如果
   表上不存在策略，将使用一条默认的否定策略，即所有的行都不可见或者不能
   被修改。应用在整个表上的操作不服从行安全性，例如<command>TRUNCATE</>和
   <literal>REFERENCES</>。
  </para>

  <para>
   行安全性策略可以针对特定的命令、角色或者两者。一条策略可以被指定为
   适用于<literal>ALL</literal>命令，或者<literal>SELECT</>、
   <literal>INSERT</>、<literal>UPDATE</>或者<literal>DELETE</>。
   可以为一条给定策略分配多个角色，并且通常的角色成员关系和继承规则也
   适用。
  </para>

  <para>
   要指定哪些行根据一条策略是可见的或者是可修改的，需要一个返回布尔结果
   的表达式。对于每一行，在计算任何来自用户查询的条件或函数之前，先会计
   算这个表达式（这条规则的唯一例外是<literal>leakproof</literal>函数，
   它们被保证不会泄露信息，优化器可能会选择在行安全性检查之前应用这类
   函数）。使该表达式不返回<literal>true</>的行将不会被处理。可以指定
   独立的表达式来单独控制哪些行可见以及哪些行被允许修改。策略表达式会作
   为查询的一部分运行并且带有运行该查询的用户的特权，但是安全性定义者函数
   可以被用来访问对调用用户不可用的数据。
  </para>

  <para>
   具有<literal>BYPASSRLS</>属性的超级用户和角色在访问一个表时总是
   可以绕过行安全性系统。表拥有者通常也能绕过行安全性，不过表拥有者
   可以选择用<link linkend="sql-altertable">ALTER
   TABLE ... FORCE ROW LEVEL SECURITY</>来服从行安全性。
  </para>

  <para>
   启用和禁用行安全性以及向表增加策略是只有表拥有者具有的特权。
  </para>

  <para>
   策略的创建可以使用<xref linkend="sql-createpolicy">命令，策略的修改
   可以使用<xref linkend="sql-alterpolicy">命令，而策略的删除可以使用
   <xref linkend="sql-droppolicy">命令。要为一个给定表启用或者禁用行
   安全性，可以使用<xref linkend="sql-altertable">命令。
  </para>

  <para>
   每一条策略都有名称并且可以为一个表定义多条策略。由于策略是表相
   关的，一个表的每一条策略都必须有一个唯一的名称。不同的表可以拥有
   相同名称的策略。
  </para>

  <para>
   当多条策略适用于一个给定查询时，会用<literal>OR</literal>
   （用于宽松的策略，这是默认的）或<literal>AND</literal>（用于限制性策略）
   将它们组合起来。这类似于一个给定角色具有它所属的所有角色的特权的规则。
   宽松与限制策略在下面讨论。
  </para>

  <para>
   作为一个简单的例子，这里是如何在<literal>account</>关系上
   创建一条策略以允许只有<literal>managers</>角色的成员能访问行，
   并且只能访问它们账户的行：
  </para>

<programlisting>
CREATE TABLE accounts (manager text, company text, contact_email text);

ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;

CREATE POLICY account_managers ON accounts TO managers
    USING (manager = current_user);
</programlisting>

  <para>
   如果没有指定角色或者使用了特殊的用户名<literal>PUBLIC</literal>，
   则该策略适用于系统上所有的用户。要允许所有用户访问<literal>users</>
   表中属于他们自己的行，可以使用一条简单的策略：
  </para>

<programlisting>
CREATE POLICY user_policy ON users
    USING (user_name = current_user);
</programlisting>

  <para>
   要对相对于可见行是被增加到表中的行使用一条不同的策略，可以使用
   <literal>WITH CHECK</>子句。这条策略将允许所有用户查看
   <literal>users</>表中的所有行，但是只能修改它们自己的行：
  </para>

<programlisting>
CREATE POLICY user_policy ON users
    USING (true)
    WITH CHECK (user_name = current_user);
</programlisting>

  <para>
   也可以用<command>ALTER TABLE</>命令禁用行安全性。禁用行安全性
   不会移除定义在表上的任何策略，它们只是被简单地忽略。然后该表中的所有
   行都是可见的并且可修改，服从于标准的 SQL 特权系统。
  </para>

  <para>
   下面是一个较大的例子，它展示了这种特性如何被用于生产环境。表
   <literal>passwd</>模拟了一个 Unix 口令文件：
  </para>

<programlisting>
-- 简单的口令文件例子
CREATE TABLE passwd (
  user_name              text UNIQUE NOT NULL,
  pwhash                text,
  uid                   int  PRIMARY KEY,
  gid                   int  NOT NULL,
  real_name             text NOT NULL,
  home_phone            text,
  extra_info            text,
  home_dir              text NOT NULL,
  shell                 text NOT NULL
);

CREATE ROLE admin;  -- 管理员
CREATE ROLE bob;    -- 普通用户
CREATE ROLE alice;  -- 普通用户

-- 填充表
INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');

-- 确保在表上启用行级安全性
ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;

-- 创建策略
-- 管理员能看见所有行并且增加任意行
CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
-- 普通用户可以看见所有行
CREATE POLICY all_view ON passwd FOR SELECT USING (true);
-- 普通用户可以更新它们自己的记录，但是限制普通用户可用的 shell
CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = username AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );

-- 允许管理员有所有普通权限
GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
-- 用户只在公共列上得到选择访问
GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
-- 允许用户更新特定行
GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;
</programlisting>

  <para>
   对于任意安全性设置来说，重要的是测试并确保系统的行为符合预期。
   使用上述的例子，下面展示了权限系统工作正确：
  </para>

<programlisting>
-- admin 可以看到所有的行和域
postgres=&gt; set role admin;
SET
postgres=&gt; table passwd;
 user_name | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------
 admin     | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

-- 测试 Alice 能做什么
postgres=&gt; set role alice;
SET
postgres=&gt; table passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;
 user_name | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+-----------+--------------+------------+-------------+-----------
 admin     | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

postgres=&gt; update passwd set user_name = 'joe';
ERROR:  permission denied for relation passwd
-- Alice 被允许更改她自己的 real_name，但不能改其他的
postgres=&gt; update passwd set real_name = 'Alice Doe';
UPDATE 1
postgres=&gt; update passwd set real_name = 'John Doe' where user_name = 'admin';
UPDATE 0
postgres=&gt; update passwd set shell = '/bin/xx';
ERROR:  new row violates WITH CHECK OPTION for "passwd"
postgres=&gt; delete from passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; insert into passwd (user_name) values ('xxx');
ERROR:  permission denied for relation passwd
-- Alice 可以更改她自己的口令；行级安全性会悄悄地阻止更新其他行
postgres=&gt; update passwd set pwhash = 'abc';
UPDATE 1
</programlisting>

  <para>
   到目前为止，所有构建的策略都是宽松的策略，这意味着当应用多个策略时，
   它们将使用<quote>OR</quote>布尔运算符进行组合。
   虽然宽松策略可以构建为仅允许访问预期情况下的行，
   但将宽松策略与限制策略（记录必须通过并且使用<quote>AND</quote>
   布尔运算符进行组合）组合来可能会更简单。
   基于上述示例，我们添加了一个限制性策略，要求管理员通过本地Unix套接字连接以访问
   <literal>passwd</literal>表的记录：
  </para>

<programlisting>
CREATE POLICY admin_local_only ON passwd AS RESTRICTIVE TO admin
    USING (pg_catalog.inet_client_addr() IS NULL);
</programlisting>

  <para>
   由于限制性策略，我们可以看到通过网络连接的管理员不会看到任何记录：
  </para>

<programlisting>
=&gt; SELECT current_user;
 current_user 
--------------
 admin
(1 row)

=&gt; select inet_client_addr();
 inet_client_addr 
------------------
 127.0.0.1
(1 row)

=&gt; SELECT current_user;
 current_user 
--------------
 admin
(1 row)

=&gt; TABLE passwd;
 user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir | shell
-----------+--------+-----+-----+-----------+------------+------------+----------+-------
(0 rows)

=&gt; UPDATE passwd set pwhash = NULL;
UPDATE 0
</programlisting>

  <para>
   参照完整性检查（例如唯一或主键约束和外键引用）总是会绕过行级安全性以
   保证数据完整性得到维护。在开发模式和行级安全性时必须小心避免
   <quote>隐通道</>通过这类参照完整性检查泄露信息。
  </para>

  <para>
   在某些环境中确保行安全性没有被应用很重要。例如，在做备份时，如果
   行安全性悄悄地导致某些行被从备份中忽略掉，这会是灾难性的。在这类
   情况下，你可以设置<xref linkend="guc-row-security">配置参数为
   <literal>off</>。这本身不会绕过行安全性，它所做的是如果任何结果会
   被一条策略过滤掉，就会抛出一个错误。然后错误的原因就可以被找到并且
   修复。
  </para>

  <para>
   在上面的例子中，策略表达式只考虑了要被访问的行中的当前值。这是最简
   单并且表现最好的情况。如果可能，最好设计行安全性应用以这种方式工作。
   如果需要参考其他行或者其他表来做出策略的决定，可以在策略表达式中通过
   使用子-<command>SELECT</>或者包含<command>SELECT</>的函数
   来实现。不过要注意这类访问可能会导致竞争条件，在不小心的情况下这可能
   会导致信息泄露。作为一个例子，考虑下面的表设计：
  </para>

<programlisting>
-- 特权组的定义
CREATE TABLE groups (group_id int PRIMARY KEY,
                     group_name text NOT NULL);

INSERT INTO groups VALUES
  (1, 'low'),
  (2, 'medium'),
  (5, 'high');

GRANT ALL ON groups TO alice;  -- alice 是管理员
GRANT SELECT ON groups TO public;

-- 用户的特权级别的定义
CREATE TABLE users (user_name text PRIMARY KEY,
                    group_id int NOT NULL REFERENCES groups);

INSERT INTO users VALUES
  ('alice', 5),
  ('bob', 2),
  ('mallory', 2);

GRANT ALL ON users TO alice;
GRANT SELECT ON users TO public;

-- 保存要被保护的信息的表
CREATE TABLE information (info text,
                          group_id int NOT NULL REFERENCES groups);

INSERT INTO information VALUES
  ('barely secret', 1),
  ('slightly secret', 2),
  ('very secret', 5);

ALTER TABLE information ENABLE ROW LEVEL SECURITY;

-- 对于安全性 group_id 大于等于一行的 group_id 的用户，
-- 这一行应该是可见的/可更新的
CREATE POLICY fp_s ON information FOR SELECT
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));
CREATE POLICY fp_u ON information FOR UPDATE
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));

-- 我们只依赖于行级安全性来保护信息表
GRANT ALL ON information TO public;
</programlisting>

  <para>
   现在假设<literal>alice</>希望更改<quote>有一点点秘密</>
   的信息，但是觉得<literal>mallory</>不应该看到该行中的新
   内容，因此她这样做：
  </para>

<programlisting>
BEGIN;
UPDATE users SET group_id = 1 WHERE user_name = 'mallory';
UPDATE information SET info = 'secret from mallory' WHERE group_id = 2;
COMMIT;
</programlisting>

  <para>
   这看起来是安全的，没有窗口可供<literal>mallory</>看到
   <quote>对 mallory 保密</>的字符串。不过，这里有一种
   竞争条件。如果<literal>mallory</>正在并行地做：
<programlisting>
SELECT * FROM information WHERE group_id = 2 FOR UPDATE;
</programlisting>
   并且她的事务处于<literal>READ COMMITTED</>模式，她就可能看到
   <quote>s对 mallory 保密</>的东西。如果她的事务在<literal>alice</>
   做完之后就到达<structname>信息</>行，这就会发生。它会阻塞等待
   <literal>alice</>的事务提交，然后拜<literal>FOR UPDATE</>子句所赐
   取得更新后的行内容。不过，对于来自<structname>users</>的隐式
   <command>SELECT</>，它<emphasis>不会</>取得一个已更新的行，
   因为子-<command>SELECT</>没有<literal>FOR UPDATE</>，相反
   会使用查询开始时取得的快照读取<structname>users</>行。因此，
   策略表达式会测试<literal>mallory</>的特权级别的旧值并且允许她看到
   被更新的行。
  </para>

  <para>
   有多种方法能解决这个问题。一种简单的答案是在行安全性策略中的
   子-<command>SELECT</>里使用<literal>SELECT ... FOR SHARE</>。
   不过，这要求在被引用表（这里是<structname>users</>）上授予
   <literal>UPDATE</>特权给受影响的用户，这可能不是我们想要的（
   但是另一条行安全性策略可能被应用来阻止它们实际使用这个特权，或者
   子-<command>SELECT</>可能被嵌入到一个安全性定义者函数中）。
   还有，在被引用的表上过多并发地使用行共享锁可能会导致性能问题，
   特别是表更新比较频繁时。另一种解决方案（如果被引用表上的更新
   不频繁就可行）是在更新被引用表时对它取一个排他锁，这样就没有
   并发事务能够检查旧的行值了。或者我们可以在提交对被引用表的更新
   之后、在做依赖于新安全性情况的更改之前等待所有并发事务结束。
  </para>

  <para>
   更多细节请见<xref linkend="sql-createpolicy">
   和<xref linkend="sql-altertable">。
  </para>

 </sect1>

 <sect1 id="ddl-schemas">
  <title>模式</title>

  <indexterm zone="ddl-schemas">
   <primary>schema</primary>
  </indexterm>

  <para>
   一个<productname>PostgreSQL</productname>数据库集簇中包含一个或更多命名的数据库。用户和用户组被整个集簇共享，但没有其他数据在数据库之间共享。任何给定客户端连接只能访问在连接中指定的数据库中的数据。
  </para>

  <note>
   <para>
    一个集簇的用户并不必拥有访问集簇中每一个数据库的权限。用户名的共享意味着不可能在同一个集簇中出现重名的不同用户，例如两个数据库中都有叫<literal>joe</>的用户。但系统可以被配置为只允许<literal>joe</>访问某些数据库。
   </para>
  </note>

  <para>
   一个数据库包含一个或多个命名<firstterm>模式</>，模式中包含着表。模式还包含其他类型的命名对象，包括数据类型、函数和操作符。相同的对象名称可以被用于不同的模式中而不会出现冲突，例如<literal>schema1</>和<literal>myschema</>都可以包含名为<literal>mytable</>的表。和数据库不同，模式并不是被严格地隔离：一个用户可以访问他们所连接的数据库中的所有模式内的对象，只要他们有足够的权限。
  </para>

  <para>
   下面是一些使用模式的原因：

   <itemizedlist>
    <listitem>
     <para>
      允许多个用户使用一个数据库并且不会互相干扰。
     </para>
    </listitem>

    <listitem>
     <para>
      将数据库对象组织成逻辑组以便更容易管理。
     </para>
    </listitem>

    <listitem>
     <para>
      第三方应用的对象可以放在独立的模式中，这样它们就不会与其他对象的名称发生冲突。     </para>
    </listitem>
   </itemizedlist>

   模式类似于操作系统层的目录，但是模式不能嵌套。
  </para>

  <sect2 id="ddl-schemas-create">
   <title>创建模式</title>

   <indexterm zone="ddl-schemas-create">
    <primary>schema</primary>
    <secondary>creating</secondary>
   </indexterm>

   <para>
    要创建一个模式，可使用<xref linkend="sql-createschema">命令，并且给出选择的模式名称。例如：
<programlisting>
CREATE SCHEMA myschema;
</programlisting>
   </para>

   <indexterm>
    <primary>qualified name</primary>
   </indexterm>

   <indexterm>
    <primary>name</primary>
    <secondary>qualified</secondary>
   </indexterm>

   <para>
    在一个模式中创建或访问对象，需要使用由模式名和表名构成的<firstterm>限定名</>，模式名和表名之间以点号分隔：
<synopsis>
<replaceable>模式</><literal>.</><replaceable>表</>
</synopsis>
    在任何需要一个表名的地方都可以这样用，包括表修改命令和后续章节要讨论的数据访问命令（为了简洁我们在这里只谈到表，但是这种方式对其他类型的命名对象同样有效，例如类型和函数）。
   </para>

   <para>
    事实上，还有更加通用的语法：
<synopsis>
<replaceable>数据库</><literal>.</><replaceable>模式</><literal>.</><replaceable>表</>
</synopsis>
    也可以使用，但是目前它只是在<foreignphrase>形式上</>与SQL标准兼容。如果我们写一个数据库名称，它必须是我们正在连接的数据库。
   </para>

   <para>
    因此，如果要在一个新模式中创建一个表，可用：
<programlisting>
CREATE TABLE myschema.mytable (
 ...
);
</programlisting>
   </para>

   <indexterm>
    <primary>schema</primary>
    <secondary>removing</secondary>
   </indexterm>

   <para>
    要删除一个为空的模式（其中的所有对象已经被删除），可用：
<programlisting>
DROP SCHEMA myschema;
</programlisting>
    要删除一个模式以及其中包含的所有对象，可用：
<programlisting>
DROP SCHEMA myschema CASCADE;
</programlisting>
    有关于此的更一般的机制请参见<xref linkend="ddl-depend">。
   </para>

   <para>
    我们常常希望创建一个由其他人所拥有的模式（因为这是将用户动作限制在良定义的名字空间中的方法之一）。其语法是：
<programlisting>
CREATE SCHEMA <replaceable>schema_name</replaceable> AUTHORIZATION <replaceable>user_name</replaceable>;
</programlisting>
    我们甚至可以省略模式名称，在此种情况下模式名称将会使用用户名，参见<xref linkend="ddl-schemas-patterns">。
   </para>

   <para>
    以<literal>pg_</>开头的模式名被保留用于系统目的，所以不能被用户所创建。
   </para>
  </sect2>

  <sect2 id="ddl-schemas-public">
   <title>公共模式</title>

   <indexterm zone="ddl-schemas-public">
    <primary>schema</primary>
    <secondary>public</secondary>
   </indexterm>

   <para>
    在前面的小节中，我们创建的表都没有指定任何模式名称。默认情况下这些表（以及其他对象）会自动的被放入一个名为<quote>public</quote>的模式中。任何新数据库都包含这样一个模式。因此，下面的命令是等效的：
<programlisting>
CREATE TABLE products ( ... );
</programlisting>
    以及：
<programlisting>
CREATE TABLE public.products ( ... );
</programlisting>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-path">
   <title>模式搜索路径</title>

   <indexterm>
    <primary>search path</primary>
   </indexterm>

   <indexterm>
    <primary>unqualified name</primary>
   </indexterm>

   <indexterm>
    <primary>name</primary>
    <secondary>unqualified</secondary>
   </indexterm>

   <para>
    限定名写起来很冗长，通常最好不要把一个特定模式名拉到应用中。因此，表名通常被使用<firstterm>非限定名</>来引用，它只由表名构成。系统将沿着一条<firstterm>搜索路径</>来决定该名称指的是哪个表，搜索路径是一个进行查看的模式列表。 搜索路径中第一个匹配的表将被认为是所需要的。如果在搜索路径中没有任何匹配，即使在数据库的其他模式中存在匹配的表名也将会报告一个错误。
   </para>

   <indexterm>
    <primary>schema</primary>
    <secondary>current</secondary>
   </indexterm>

   <para>
    搜索路径中的第一个模式被称为当前模式。除了是第一个被搜索的模式外，如果<command>CREATE TABLE</>命令没有指定模式名，它将是新创建表所在的模式。
   </para>

   <indexterm>
    <primary><varname>search_path</varname>配置参数</primary>
   </indexterm>

   <para>
    要显示当前搜索路径，使用下面的命令：
<programlisting>
SHOW search_path;
</programlisting>
    在默认设置下这将返回：
<screen>
 search_path
--------------
 "$user",public
</screen>
    第一个元素说明一个和当前用户同名的模式会被搜索。如果不存在这个模式，该项将被忽略。第二个元素指向我们已经见过的公共模式。
   </para>

   <para>
    搜索路径中的第一个模式是创建新对象的默认存储位置。这就是默认情况下对象会被创建在公共模式中的原因。当对象在任何其他没有模式限定的环境中被引用（表修改、数据修改或查询命令）时，搜索路径将被遍历直到一个匹配对象被找到。因此，在默认配置中，任何非限定访问将只能指向公共模式。
   </para>

   <para>
    要把新模式放在搜索路径中，我们可以使用：
<programlisting>
SET search_path TO myschema,public;
</programlisting>
    （我们在这里省略了<literal>$user</literal>，因为我们并不立即需要它）。然后我们可以该表而无需使用模式限定：
<programlisting>
DROP TABLE mytable;
</programlisting>
    同样，由于<literal>myschema</literal>是路径中的第一个元素，新对象会被默认创建在其中。
   </para>

   <para>
    我们也可以这样写：
<programlisting>
SET search_path TO myschema;
</programlisting>
    这样我们在没有显式限定时再也不必去访问公共模式了。公共模式没有什么特别之处，它只是默认存在而已，它也可以被删除。
   </para>

   <para>
    其他操作模式搜索路径的方法请见<xref linkend="functions-info">。
   </para>

   <para>
    搜索路径对于数据类型名称、函数名称和操作符名称的作用与表名一样。数据类型和函数名称可以使用和表名完全相同的限定方式。如果我们需要在一个表达式中写一个限定的操作符名称，我们必须写成一种特殊的形式：
<synopsis>
<literal>OPERATOR(</><replaceable>schema</><literal>.</><replaceable>operator</><literal>)</>
</synopsis>
    这是为了避免句法歧义。例如：
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
    实际上我们通常都会依赖于搜索路径来查找操作符，因此没有必要去写如此“丑陋”的东西。
   </para>
  </sect2>

  <sect2 id="ddl-schemas-priv">
   <title>模式和权限</title>

   <indexterm zone="ddl-schemas-priv">
    <primary>privilege</primary>
    <secondary sortas="schemas">for schemas</secondary>
   </indexterm>

   <para>
    默认情况下，用户不能访问不属于他们的模式中的任何对象。要允许这种行为，模式的拥有者必须在该模式上授予<literal>USAGE</literal>权限。为了允许用户使用模式中的对象，可能还需要根据对象授予额外的权限。
   </para>

   <para>
    一个用户也可以被允许在其他某人的模式中创建对象。要允许这种行为，模式上的<literal>CREATE</literal>权限必须被授予。注意在默认情况下，所有人都拥有在<literal>public</literal>模式上的<literal>CREATE</literal>和<literal>USAGE</literal>权限。这使得用户能够连接到一个给定数据库并在它的<literal>public</literal>模式中创建对象。如果不希望允许这样，可以撤销该权限：
<programlisting>
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
</programlisting>
    （第一个<quote>public</quote>是模式，第二个<quote>public</quote>指的是 <quote>每一个用户</quote>。第一种是一个标识符，第二种是一个关键词，所以两者的大小写不同。请回想<xref linkend="sql-syntax-identifiers">中的指导方针。）
   </para>
  </sect2>

  <sect2 id="ddl-schemas-catalog">
   <title>系统目录模式</title>

   <indexterm zone="ddl-schemas-catalog">
    <primary>system catalog</primary>
    <secondary>schema</secondary>
   </indexterm>

   <para>
    除<literal>public</>和用户创建的模式之外，每一个数据库还包括一个<literal>pg_catalog</>模式，它包含了系统表和所有内建的数据类型、函数以及操作符。<literal>pg_catalog</>总是搜索路径的一个有效部分。如果没有在路径中显式地包括该模式，它将在路径中的模式<emphasis>之前</>被搜索。这保证了内建的名称总是能被找到。然而，如果我们希望用用户定义的名称重载内建的名称，可以显式的将<literal>pg_catalog</>放在搜索路径的末尾。
   </para>

   <para>
    由于系统表名称以<literal>pg_</>开头，最好还是避免使用这样的名称，以避免和未来新版本中
    可能出现的系统表名发生冲突。系统表将继续采用以<literal>pg_</>开头的方式，这样它们不会
    与非限制的用户表名称冲突。
   </para>
  </sect2>

  <sect2 id="ddl-schemas-patterns">
   <title>惯用法</title>

   <para>
    模式可以被用来以多种方式组织我们的数据。在默认配置下，一些常见的用法是：
    <itemizedlist>
     <listitem>
      <para>
       如果我们不创建任何模式则所有用户会隐式地访问公共模式。这就像根本不存在模式一样。当数据库中只有一个用户或者少量合作用户时，推荐使用这种配置。这种配置使得我们很容易从没有模式的环境中转换过来。
      </para>
     </listitem>

     <listitem>
      <para>
       我们可以为每一个用户创建与它同名的模式。回想一下，默认的搜索路径以<literal>$user</literal>开始，它将会被解析成用户名。因此，如果每一个用户有一个独立的模式，它们将会默认访问自己的模式。
      </para>

      <para>
       如果我们使用这种配置，则我们可能也希望撤销到公共模式的访问（或者把它也一起删除），这样用户被真正地限制在他们自己的模式中。
      </para>
     </listitem>

     <listitem>
      <para>
       要安装共享的应用（任何人都可以用的表、由第三方提供的附加函数等），将它们放在独立的模式中。记住要授予适当的权限以允许其他用户访问它们。然后用户就可以使用带模式名的限定名称来引用这些附加对象，或者他们可以把附加模式放入到他们的搜索路径中。
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-portability">
   <title>可移植性</title>

   <para>
    在SQL标准中，在由不同用户拥有的同一个模式中的对象是不存在的。此外，某些实现不允许创建与拥有者名称不同名的模式。事实上，在那些仅实现了标准中基本模式支持的数据库中，模式和用户的概念是等同的。因此，很多用户认为限定名称实际上是由<literal><replaceable>user_name</>.<replaceable>table_name</></literal>组成的。如果我们为每一个用户都创建了一个模式，<productname>PostgreSQL</productname>实际也是这样认为的。
   </para>

   <para>
    同样，在SQL标准中也没有<literal>public</>模式的概念。为了最大限度的与标准一致，我们不应使用（甚至是删除）<literal>public</>模式。
   </para>

   <para>
    当然，某些SQL数据库系统可能根本没有实现模式，或者提供允许跨数据库访问的名字空间。如果需要使用这样一些系统，最好不要使用模式。
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-inherit">
  <title>继承</title>

  <indexterm>
   <primary>inheritance</primary>
  </indexterm>

  <indexterm>
   <primary>table</primary>
   <secondary>inheritance</secondary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname>实现了表继承，这对数据库设计者来说是一种有用的工具（SQL:1999及其后的版本定义了一种类型继承特性，但和这里介绍的继承有很大的不同）。
  </para>

  <para>
   让我们从一个例子开始：假设我们要为城市建立一个数据模型。每一个州有很多城市，但是只有一个首府。我们希望能够快速地检索任何特定州的首府城市。这可以通过创建两个表来实现：一个用于州首府，另一个用于不是首府的城市。然而，当我们想要查看一个城市的数据（不管它是不是一个首府）时会发生什么？继承特性将有助于解决这个问题。我们可以将<structname>capitals</structname>表定义为继承自<structname>cities</structname>表：

<programlisting>
CREATE TABLE cities (
    name            text,
    population      float,
    altitude        int     -- in feet
);

CREATE TABLE capitals (
    state           char(2)
) INHERITS (cities);
</programlisting>

   在这种情况下，<structname>capitals</>表<firstterm>继承</>了它的父表<structname>cities</>的所有列。州首府还有一个额外的列<structfield>state</>用来表示它所属的州。
  </para>

  <para>
   在<productname>PostgreSQL</productname>中，一个表可以从0个或者多个其他表继承，而对一个表的查询则可以引用一个表的所有行或者该表的所有行加上它所有的后代表。默认情况是后一种行为。例如，下面的查询将查找所有海拔高于500尺的城市的名称，包括州首府：

<programlisting>
SELECT name, altitude
    FROM cities
    WHERE altitude &gt; 500;
</programlisting>

   对于来自<productname>PostgreSQL</productname>教程（见<xref linkend="tutorial-sql-intro">）的例子数据，它将返回：

<programlisting>
   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845
</programlisting>
  </para>

  <para>
   在另一方面，下面的查询将找到海拔超过500尺且不是州首府的所有城市：

<programlisting>
SELECT name, altitude
    FROM ONLY cities
    WHERE altitude &gt; 500;

   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
</programlisting>
  </para>

  <para>
   这里的<literal>ONLY</literal>关键词指示查询只被应用于<structname>cities</structname>上，而其他在继承层次中位于<structname>cities</structname>之下的其他表都不会被该查询涉及。很多我们已经讨论过的命令（如<command>SELECT</command>、<command>UPDATE</command>和<command>DELETE</command>）都支持<literal>ONLY</literal>关键词。
  </para>

  <para>
   我们也可以在表名后写上一个<literal>*</>来显式地将后代表包括在查询范围内：

<programlisting>
SELECT name, altitude
    FROM cities*
    WHERE altitude &gt; 500;
</programlisting>

   <literal>*</>并不是必须的，因为这种行为总是默认的。
   但是，仍支持此语法以与更改默认值的旧版本兼容。
  </para>

  <para>
   在某些情况下，我们可能希望知道一个特定行来自于哪个表。每个表中的系统列<structfield>tableoid</structfield>可以告诉我们行来自于哪个表：

<programlisting>
SELECT c.tableoid, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;
</programlisting>

   将会返回：

<programlisting>
 tableoid |   name    | altitude
----------+-----------+----------
   139793 | Las Vegas |     2174
   139793 | Mariposa  |     1953
   139798 | Madison   |      845
</programlisting>

   （如果重新生成这个结果，可能会得到不同的OID数字。）通过与<structname>pg_class</>进行连接可以看到实际的表名：

<programlisting>
SELECT p.relname, c.name, c.altitude
FROM cities c, pg_class p
WHERE c.altitude &gt; 500 AND c.tableoid = p.oid;
</programlisting>

   将会返回：

<programlisting>
 relname  |   name    | altitude
----------+-----------+----------
 cities   | Las Vegas |     2174
 cities   | Mariposa  |     1953
 capitals | Madison   |      845
</programlisting>
  </para>
  
  <para>
   另一种得到同样效果的方法是使用<type>regclass</>别名类型，
   它将象征性地打印出表的 OID：

<programlisting>
SELECT c.tableoid::regclass, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;
</programlisting>
  </para>

  <para>
   继承不会自动地将来自<command>INSERT</command>或<command>COPY</command>命令的数据传播到继承层次中的其他表中。在我们的例子中，下面的<command>INSERT</command>语句将会失败：
<programlisting>
INSERT INTO cities (name, population, altitude, state)
VALUES ('Albany', NULL, NULL, 'NY');
</programlisting>
   我们也许希望数据能被以某种方式被引入到<structname>capitals</structname>表中，但是这不会发生：<command>INSERT</command>总是向指定的表中插入。在某些情况下，可以通过使用一个规则（见<xref linkend="rules">）来将插入动作重定向。但是这对上面的情况并没有帮助，因为<structname>cities</>表根本就不包含<structfield>state</>列，因而这个命令将在触发规则之前就被拒绝。
  </para>

  <para>
   父表上的所有检查约束和非空约束都将自动被它的后代所继承，
   除非使用 <literal>NO INHERIT</>子句明确指定。其他类型的约束（唯一、主键和外键约束）则不会被继承。
  </para>

  <para>
   一个表可以从超过一个的父表继承，在这种情况下它拥有父表们所定义的列的并集。任何定义在子表上的列也会被加入到其中。如果在这个集合中出现重名列，那么这些列将被<quote>合并</>，这样在子表中只会有一个这样的列。重名列能被合并的前提是这些列必须具有相同的数据类型，否则会导致错误。
   以类似的方式合并可继承检查约束和非空约束。因此，例如，
   如果其来自的列定义中的任何一个被标记为非空，则合并列将被标记为非空。
   如果检查约束具有相同的名称，则检查约束将被合并，并且如果条件不同，合并将失败。
  </para>

  <para>
   表继承通常是在子表被创建时建立，使用<xref linkend="sql-createtable">语句的<literal>INHERITS</>子句。一个已经被创建的表也可以另外一种方式增加一个新的父亲关系，使用<xref linkend="sql-altertable">的<literal>INHERIT</literal>变体。要这样做，新的子表必须已经包括和父表相同名称和数据类型的列。子表还必须包括和父表相同的检查约束和检查表达式。相似地，一个继承链接也可以使用<command>ALTER TABLE</>的 <literal>NO INHERIT</literal>变体从一个子表中移除。动态增加和移除继承链接可以用于实现表划分（见<xref linkend="ddl-partitioning">）。
  </para>

  <para>
   一种创建一个未来将被用做子女的新表的方法是在<command>CREATE
   TABLE</command>中使用<literal>LIKE</literal>子句。这将创建一个和源表具有相同列的新表。如果源表上定义有任何<literal>CHECK</literal>约束，<literal>LIKE</literal>的<literal>INCLUDING CONSTRAINTS</literal>选项可以用来让新的子表也包含和父表相同的约束。
  </para>

  <para>
   当有任何一个子表存在时，父表不能被删除。当子表的列或者检查约束继承于父表时，它们也不能被删除或修改。如果希望移除一个表和它的所有后代，一种简单的方法是使用<literal>CASCADE</literal>选项删除父表（见<xref linkend="ddl-depend">）。
  </para>

  <para>
   <xref linkend="sql-altertable">将会把列的数据定义或检查约束上的任何变化沿着继承层次向下传播。同样，删除被其他表依赖的列只能使用<literal>CASCADE</literal>选项。<command>ALTER TABLE</command>对于重名列的合并和拒绝遵循与<command>CREATE TABLE</command>同样的规则。
  </para>

  <para>
   继承的查询只对父表执行访问权限检查。因此，例如，在<structname>cities</>
   表上授予<literal>UPDATE</>权限意味着也更新<structname>capitals</structname>
   表中的行的权限，当它们通过<structname>cities</>访问时。
   这说明了这些数据（也）在父表中。但是，如果没有额外的授权，
   不能直接更新<structname>capitals</structname>表。类似的，在继承查询期间，
   父表的行安全策略（请参阅<xref linkend="ddl-rowsecurity">）
   将应用到来自子表的行。子表的策略（如果有的话）仅在查询中显式指定该表时应用；
   在这种情况下，任何附属于其父母的策略都将被忽略。
  </para>
  
  <para>
   外部表（见<xref linkend="ddl-foreign-data">）也可以是继承层次
   中的一部分，即可以作为父表也可以作为子表，就像常规表一样。如果
   一个外部表是继承层次的一部分，那么任何不被该外部表支持的操作也
   不被整个层次所支持。
  </para>

 <sect2 id="ddl-inherit-caveats">
  <title>警告</title>

  <para>
   注意并非所有的SQL命令都能工作在继承层次上。用于数据查询、数据修改或模式修改（例如<literal>SELECT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>、大部分<literal>ALTER TABLE</literal>的变体，但<literal>INSERT</literal>或<literal>ALTER TABLE ... RENAME</literal>不在此列）的命令会默认将子表包含在内并且支持<literal>ONLY</literal>记号来排除子表。负责数据库维护和调整的命令（如<literal>REINDEX</literal>、<literal>VACUUM</literal>）只工作在独立的、物理的表上并且不支持在继承层次上的递归。每个命令相应的行为请参见它们的参考页（<xref linkend="sql-commands">）。
  </para>

  <para>
   继承特性的一个严肃的限制是索引（包括唯一约束）和外键约束值应用在单个表上而非它们的继承子女。在外键约束的引用端和被引用端都是这样。因此，按照上面的例子：

   <itemizedlist>
    <listitem>
     <para>
      如果我们声明<structname>cities</>.<structfield>name</>为<literal>UNIQUE</>或者<literal>PRIMARY KEY</>，这将不会阻止<structname>capitals</>表中拥有和<structname>cities</>中城市同名的行。而且这些重复的行将会默认显示在<structname>cities</>的查询中。事实上，<structname>capitals</>在默认情况下是根本不能拥有唯一约束的，并且因此能够包含多个同名的行。我们可以为<structname>capitals</>增加一个唯一约束，但这无法阻止相对于<structname>cities</>的重复。
     </para>
    </listitem>

    <listitem>
     <para>
      相似地，如果我们指定<structname>cities</>.<structfield>name</> <literal>REFERENCES</>某个其他表，该约束不会自动地传播到<structname>capitals</>。在此种情况下，我们可以变通地在<structname>capitals</>上手工创建一个相同的<literal>REFERENCES</>约束。
     </para>
    </listitem>

    <listitem>
     <para>
      指定另一个表的列<literal>REFERENCES cities(name)</>将允许其他表包含城市名称，但不会包含首府名称。这对于这个例子不是一个好的变通方案。
     </para>
    </listitem>
   </itemizedlist>

   这些不足可能还将存在于某些未来的发布中，但是同时在决定继承是否对我们的应用有用时需要相当小心。
  </para>

   </sect2>
  </sect1>

  <sect1 id="ddl-partitioning">
   <title>表分区</title>

   <indexterm>
    <primary>分区</primary>
   </indexterm>

   <indexterm>
    <primary>table</primary>
    <secondary>分区</secondary>
   </indexterm>
   <indexterm>
    <primary>分区表</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname>支持基本的表划分。本小节介绍为何以及怎样把划分实现为数据库设计的一部分。
   </para>

   <sect2 id="ddl-partitioning-overview">
     <title>概述</title>

   <para>
    划分指的是将逻辑上的一个大表分成一些小的物理上的片。划分有很多益处：
   <itemizedlist>
    <listitem>
     <para>
      在某些情况下查询性能能够显著提升，特别是当那些访问压力大的行在一个分区或者少数几个分区时。划分可以取代索引的主导列、减小索引尺寸以及使索引中访问压力大的部分更有可能被放在内存中。
     </para>
    </listitem>

    <listitem>
     <para>
      当查询或更新访问一个分区的大部分行时，可以通过该分区上的一个顺序扫描来取代分散到整个表上的索引和随机访问，这样可以改善性能。
     </para>
    </listitem>

    <listitem>
     <para>
      如果需求计划使用划分设计，可以通过增加或移除分区来完成批量载入和删除。
	  执行<command>ALTER TABLE DETACH PARTITION</>或者使用<command>DROP TABLE</>
	  删除一个单独的分区都远快于一个批量操作。这些命令也完全避免了由批量<command>DELETE</>造成的<command>VACUUM</command>负载。
     </para>
    </listitem>

    <listitem>
     <para>
      很少使用的数据可以被迁移到便宜且较慢的存储介质上。
     </para>
    </listitem>
   </itemizedlist>

    当一个表非常大时，划分所带来的好处是非常值得的。一个表何种情况下会从划分获益取决于应用，一个经验法则是当表的尺寸超过了数据库服务器物理内存时，划分会为表带来好处。
   </para>

    <para>
     <productname>PostgreSQL</productname>为以下形式的分区提供了内置支持：

     <variablelist>
      <varlistentry>
       <term>范围分区</term>

       <listitem>
        <para>
         该表被分区到由键列或列集定义的<quote>范围</quote>中，
		 分配给不同分区的值范围之间没有重叠。例如，可以按日期范围进行分区，
		 也可以按特定业务对象的标识符范围进行分区。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>列表分区</term>

       <listitem>
        <para>
         表通过明确列出每个分区中出现的键值进行分区。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     如果您的应用程序需要使用上面未列出的其他形式的分区，则可以使用替代方法，
	 如继承和<literal>UNION ALL</literal>视图。这种方法提供了灵活性，
	 但没有内置声明式分区的一些性能优势。
    </para>
   </sect2>

  <sect2 id="ddl-partitioning-declarative">
   <title>声明式分区</title>

   <para>
    <productname>PostgreSQL</productname>提供了一种方法来指定如何将表分成多个分区。
	被分割的表被称为<firstterm>分区表</firstterm>。
	该规范由<firstterm>分区方法</firstterm>以及要用作<firstterm>分区键</firstterm>
	的列或表达式列表组成。
   </para>
   <para>
    插入到分区表中的所有行将根据分区键的值分配到<firstterm>分区</firstterm>之一。
	每个分区都有由其<firstterm>分区边界</firstterm>定义的数据子集。
	目前支持的分区方法包括范围和列表，其中每个分区分别分配键的范围和键的列表。
   </para>

   <para>
    分区本身可以被定义为分区表，使用所谓的<firstterm>子分区</firstterm>。
	分区可以有自己的索引、约束和默认值，与其他分区不同。
	索引必须为每个分区单独创建。有关创建分区表和分区的更多详细信息，
	请参见<xref linkend="sql-createtable">。
   </para>   

   <para>
    无法将常规表格转换为分区表格，反之亦然。但是，
	可以将包含数据的普通表或分区表添加为分区表的分区，或从分区表中删除分区，
	将其转换为独立表；请参阅<xref linkend="sql-altertable">以了解有关
	<command>ATTACH PARTITION</>和<command>DETACH PARTITION</>子命令的更多信息。
   </para>

   <para>
    单个分区链接到分区表，并在后台继承；但是，
	不可能将前一节中讨论的某些继承特性与分区表和分区一起使用。例如，
	分区不能拥有除分区表之外的其他父项，普通表也不能从分区表继承，
	使后者成为其父项。这意味着分区表和分区不参与普通表的继承。
	由于由分区表及其分区构成的分区层次结构仍然是继承层次结构，
	因此除了一些例外情况外，所有正常的继承规则都适用，
	如<xref linkend="ddl-inherit">中所述，最重要的是：

    <itemizedlist>
     <listitem>
      <para>
       分区表的<literal>CHECK</literal>和<literal>NOT NULL</literal>
	   约束总是被它的所有分区继承。不允许在分区表上创建标记为
	   <literal>NO INHERIT</literal>的<literal>CHECK</literal>约束。
      </para>
     </listitem>

     <listitem>
      <para>
       当没有分区时，仅支持使用<literal>ONLY</literal>在分区表上添加或删除约束。
	   一旦存在分区，使用<literal>ONLY</literal>会导致错误，
	   因为仅支持在分区表上添加或删除约束，当分区存在时是不支持的。
	   相反，当不存在父表时，可以直接在分区上添加或删除约束。
	   由于分区表不直接拥有任何数据，因此尝试在分区表上使用
	   <command>TRUNCATE</command> <literal>ONLY</literal>将始终返回错误。
      </para>
     </listitem>

     <listitem>
      <para>
       分区不能拥有父表中不存在的列。在使用<command>CREATE TABLE</>
	   创建分区时不能声明字段，也不能在创建完分区后使用<command>ALTER TABLE</>
	   添加字段。仅当表的列准确匹配分区表，包括<literal>oid</literal>列时，
	   才可以使用<command>ALTER TABLE ... ATTACH PARTITION</>
	   将该表添加为分区。
      </para>
     </listitem>

     <listitem>
      <para>
       如果<literal>NOT NULL</literal>约束存在于父表上，那么你不能删除分区字段上的该约束。
      </para>
     </listitem>
    </itemizedlist>
   </para>
   <para>
    分区也可以是外表（参阅<xref linkend="sql-createforeigntable">），
	尽管它们会有一些普通表没有的限制。例如，插入到分区表的数据不会传到外表分区中。
   </para>

   <sect3 id="ddl-partitioning-declarative-example">
    <title>示例</title>

    <para>
     假设我们正在为一个大型的冰淇淋公司构建一个数据库。该公司测量每天在每一个区域的最高气温以及冰淇淋销售。在概念上，我们想要一个这样的表：

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);
</programlisting>

     由于该表的主要用途是为管理层提供在线报告，我们知道大部分查询将只会访问上周、上月或者上季度的数据。为了减少需要保存的旧数据的量，我们决定只保留最近3年的数据。在每一个月的开始，我们将删除最老的一个月的数据。
     在这种情况下，我们可以使用划分来帮助我们满足对于测量表的所有不同需求。
    </para>
   <para>
    要在这种情况下使用声明式分区，请使用以下步骤：

    <orderedlist spacing="compact">
     <listitem>
      <para>
       通过声明<literal>PARTITION BY</literal>子句将
	   <structname>measurement</structname>表创建为分区表，
	   它包括分区方法（该例中是<literal>RANGE</literal>）
	   和要用作分区键的字段。

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</programlisting>
      </para>
      <para>
       如果需要，您可以决定在分区键中使用多个列进行范围分区。当然，
	   这通常会导致更大数量的分区，每个分区都较小。另一方面，
	   使用较少的列可能会导致较小的分区数量的较粗粒度分区标准。
	   如果查询条件涉及部分或全部这些列，则访问分区表的查询将不得不扫描较少的分区。
	   例如，考虑使用列<structfield>lastname</>和<structfield>firstname</>
	   （按此顺序）作为分区键分区的表范围。
      </para>
     </listitem>

     <listitem>
      <para>
       创建分区。每个分区的定义必须声明对应于父表分区方法和分区键的范围。
	   请注意，新分区的声明范围值覆盖现有分区的值将导致一个错误。
	   插入到父表的数据不能映射到现有分区之一的话讲导致一个错误；
	   必须手动添加适当的分区。
      </para>

      <para>
       这样创建的分区在各方面都是普通<productname>PostgreSQL</>表
	   （或者可能是外表）。可以单独为每个分区指定表空间和存储参数。
      </para>

      <para>
       不需要为分区创建描述分区范围条件的表约束。
	   在需要引用时，分区约束是隐式的从分区范围声明中生成的。

<programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01')

CREATE TABLE measurement_y2006m03 PARTITION OF measurement
    FOR VALUES FROM ('2006-03-01') TO ('2006-04-01')

...
CREATE TABLE measurement_y2007m11 PARTITION OF measurement
    FOR VALUES FROM ('2007-11-01') TO ('2007-12-01')

CREATE TABLE measurement_y2007m12 PARTITION OF measurement
    FOR VALUES FROM ('2007-12-01') TO ('2008-01-01')
    TABLESPACE fasttablespace;

CREATE TABLE measurement_y2008m01 PARTITION OF measurement
    FOR VALUES FROM ('2008-01-01') TO ('2008-02-01')
    TABLESPACE fasttablespace
    WITH (parallel_workers = 4);
</programlisting>
      </para>
      <para>
       要实现子分区，在创建单个分区的语句中声明<literal>PARTITION BY</literal>
	   子句，例如：
<programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01')
    PARTITION BY RANGE (peaktemp);
</programlisting>

       在创建了<structname>measurement_y2006m02</>的分区之后，
	   插入到<structname>measurement</>映射到<structname>measurement_y2006m02</>
	   （或直接插入到<structname>measurement_y2006m02</>中的数据，
	   只要它满足其分区约束）的数据将根据<structfield>peaktemp</>
	   列进一步重定向到其分区之一。指定的分区键可能与父分区键重叠，
	   但在指定子分区的边界时应该小心，
	   以使其接受的数据集构成分区自己的界限允许的子集；
	   系统不会试图检查是否确实如此。
      </para>
     </listitem>

     <listitem>
      <para>
       对于每一个分区，在键列上创建索引，以及您可能需要的其他索引。
	   （键索引不是绝对必要的，但在大多数情况下它都是有用的。
	   如果您希望键值是唯一的，那么您还要为每个分区创建一个唯一或主键约束。）

<programlisting>
CREATE INDEX ON measurement_y2006m02 (logdate);
CREATE INDEX ON measurement_y2006m03 (logdate);
...
CREATE INDEX ON measurement_y2007m11 (logdate);
CREATE INDEX ON measurement_y2007m12 (logdate);
CREATE INDEX ON measurement_y2008m01 (logdate);
</programlisting>
      </para>
     </listitem>
      <listitem>
       <para>
        确保在<filename>postgresql.conf</>中<xref linkend="guc-constraint-exclusion">配置参数没有被禁用。如果它被禁用，查询将不会被按照期望的方式优化。
       </para>
      </listitem>
    </orderedlist>
   </para>
   <para>
    在上面的例子中，我们将每个月创建一个新的分区，
	所以编写一个脚本可以自动生成所需的DDL。
   </para>
   </sect3>
   <sect3 id="ddl-partitioning-declarative-maintenance">
    <title>分区维护</title>
   <para>
     通常当初始定义的表倾向于动态变化时，一组分区会被创建。删除旧的分区并周期性地为新数据增加新分区是很常见的。划分的一个最重要的优点是可以通过操纵分区结构来使得这种痛苦的任务几乎是自发地完成，而不需要去物理地移除大量的数据。
   </para>

   <para>
     移除旧数据的最简单的选项是删除不再需要的分区：
<programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
     这可以非常快地删除百万级别的记录，因为它不需要逐一地删除记录。
	 不过，请注意，上述命令需要在父表上获取一个<literal>ACCESS EXCLUSIVE</literal>锁。
   </para>

   <para>
     另一个经常使用的选项是将分区从被划分的表中移除，但是把它作为一个独立的表保留下来：
<programlisting>
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02;
</programlisting>
     这允许在数据被删除前执行更进一步的操作。例如，这是一个很有用的时机通过<command>COPY</>、<application>pg_dump</>或类似的工具来备份数据。这也是进行数据聚集、执行其他数据操作或运行报表的好时机。
   </para>

   <para>
     相似地我们也可以增加新分区来处理新数据。我们可以在被划分的表中创建一个新的空分区：

<programlisting>
CREATE TABLE measurement_y2008m02 PARTITION OF measurement
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01')
    TABLESPACE fasttablespace;
</programlisting>

     作为一种选择方案，有时创建一个在分区结构之外的新表更方便，并且在以后才将它作为一个合适的分区。这使得数据可以在出现于被划分表中之前被载入、检查和转换：

<programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS)
  TABLESPACE fasttablespace;

ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );

\copy measurement_y2008m02 from 'measurement_y2008m02'
-- 可能做一些其他数据准备工作

ALTER TABLE measurement ATTACH PARTITION measurement_y2008m02
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01' );
</programlisting>
    </para>
    <para>
     在运行<command>ATTACH PARTITION</>命令之前，
	 建议在要附加的表上创建一个<literal>CHECK</>约束来描述所需的分区约束。
	 这样，系统将能够跳过扫描来验证隐式分区约束。如果没有这样的约束，
	 将在父表上保存一个<literal>ACCESS EXCLUSIVE</literal>
	 锁来扫描该表以验证分区约束。然后可以在<command>ATTACH PARTITION</>
	 完成后删除约束，因为它不再是必需的。	 
    </para>
	</sect3>

   <sect3 id="ddl-partitioning-declarative-limitations">
    <title>限制</title>
   <para>
    以下限制适用于分区表：
    <itemizedlist>
     <listitem>
      <para>
       没有工具可用于在所有分区上自动创建匹配索引。
	   索引必须通过单独的命令添加到每个分区。
	   这也意味着无法创建跨所有分区的主键、唯一约束或排除约束；
	   只能分别约束每个叶子分区。
      </para>
     </listitem>

     <listitem>
      <para>
       由于分区表上不支持主键，因此不支持引用分区表的外键，
	   也不支持将分区表中的外键引用到某个其他表。
      </para>
     </listitem>
     <listitem>
      <para>
       对分区表使用<literal>ON CONFLICT</literal>子句会导致错误，
	   因为唯一或排除约束只能在单个分区上创建。
	   不支持在整个分区层次结构中实施唯一性（或排除约束）。
      </para>
     </listitem>
     <listitem>
      <para>
       导致行从一个分区移动到另一个分区的<command>UPDATE</>失败，
	   因为该行的新值无法满足原始分区的隐式分区约束。
      </para>
     </listitem>

     <listitem>
      <para>
       必要时，行触发器必须在单独的分区上定义，而不是在分区表上定义。
      </para>
     </listitem>
    </itemizedlist>
    </para>
    </sect3>


	</sect2>
   <sect2 id="ddl-partitioning-implementation-inheritance">
    <title>使用继承的实现</title>
    <para>
     尽管内置的声明式分区适用于大多数常见用例，但在某些情况下，
	 更灵活的方法可能会有用。可以使用表继承来实现分区，
	 这允许声明式分区不支持的几个功能，例如：

     <itemizedlist>
      <listitem>
       <para>
        分区强制执行一条规则，即所有分区必须与父表具有完全相同的一组列，
		但表继承允许子表具有不在父表中的额外列。
       </para>
      </listitem>

      <listitem>
       <para>
        表继承允许多重继承。
       </para>
      </listitem>

      <listitem>
       <para>
        声明式分区仅支持列表和范围分区，而表继承允许按照用户选择的方式分割数据。
		（但是，请注意，如果约束排除无法有效地修剪分区，查询性能将会很差。）
       </para>
      </listitem>

      <listitem>
       <para>
        有些操作在使用声明式分区时需要比使用表继承时更强的锁定。例如，
		向分区表添加或删除分区需要在父表上使用<literal>ACCESS EXCLUSIVE</literal>锁，
		而在普通继承的情况下<literal>SHARE UPDATE EXCLUSIVE</literal>锁就足够了。
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <sect3 id="ddl-partitioning-inheritance-example">
     <title>示例</title>
     <para>
      我们使用上面使用的相同的<structname>measurement</structname>表。
	  要使用继承将其作为分区表来实现，请使用以下步骤：
      <orderedlist spacing="compact">
      <listitem>
       <para>
        创建<quote>主</quote>表，所有的分区都将继承它。
        这个表将不会包含任何数据。不要在这个表上定义任何检查约束，
		除非准备将它们应用到所有分区。同样也不需要定义任何索引或者唯一约束。
		在我们的示例中，主表是之前定义的<structname>measurement</structname>表。
       </para>
      </listitem>
      <listitem>
       <para>
        创建一些继承于主表的<quote>子</quote>表。通常，
		这些表不会在从主表继承的列集中增加任何列。
		就像声明式分区一样，这些分区在各个方面都是普通的
		<productname>PostgreSQL</>表（或外部表）。
       </para>
	   
        <para>
<programlisting>
CREATE TABLE measurement_y2006m02 () INHERITS (measurement);
CREATE TABLE measurement_y2006m03 () INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 () INHERITS (measurement);
CREATE TABLE measurement_y2007m12 () INHERITS (measurement);
CREATE TABLE measurement_y2008m01 () INHERITS (measurement);
</programlisting>
        </para>
       </listitem>	   
	   
	   

      <listitem>
       <para>
         将不重叠的表约束添加到分区表中以定义每个分区中允许的键值。
        </para>

        <para>
         典型的例子是：
<programlisting>
CHECK ( x = 1 )
CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
CHECK ( outletID &gt;= 100 AND outletID &lt; 200 )
</programlisting>

         确保约束保证不同分区中允许的键值之间没有重叠。
		 一个常见的错误是设置范围约束，如：
<programlisting>
CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )
</programlisting>
         这是错误的，因为不清楚键值200属于哪个分区。
        </para>

       <para>
         最好是如下所示创建分区：

<programlisting>
CREATE TABLE measurement_y2006m02 (
    CHECK ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
) INHERITS (measurement);
CREATE TABLE measurement_y2006m03 (
    CHECK ( logdate &gt;= DATE '2006-03-01' AND logdate &lt; DATE '2006-04-01' )
) INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 (
    CHECK ( logdate &gt;= DATE '2007-11-01' AND logdate &lt; DATE '2007-12-01' )
) INHERITS (measurement);
CREATE TABLE measurement_y2007m12 (
    CHECK ( logdate &gt;= DATE '2007-12-01' AND logdate &lt; DATE '2008-01-01' )
) INHERITS (measurement);
CREATE TABLE measurement_y2008m01 (
    CHECK ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
) INHERITS (measurement);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
         对于每个分区，在键列上创建一个索引，以及您可能需要的任何其他索引。

<programlisting>
CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);
CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);
CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);
CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);
CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);
</programlisting>

       </para>
      </listitem>

      <listitem>
       <para>
        我们希望我们的应用能够使用<literal>INSERT INTO measurement ...</>并且数据将被重定向到合适的分区表。我们可以通过为主表附加一个合适的触发器函数来实现这一点。如果数据将只被增加到最后一个分区，我们可以使用一个非常简单的触发器函数：


<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>
        </para>

        <para>
        完成函数创建后，我们创建一个调用该触发器函数的触发器：


<programlisting>
CREATE TRIGGER insert_measurement_trigger
    BEFORE INSERT ON measurement
    FOR EACH ROW EXECUTE PROCEDURE measurement_insert_trigger();
</programlisting>

        我们必须在每个月重新定义触发器函数，这样它才会总是指向当前分区。而触发器的定义则不需要被更新。
       </para>

       <para>
        我们也可能希望插入数据时服务器会自动地定位应该加入数据的分区。我们可以通过一个更复杂的触发器函数来实现之，例如：

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF ( NEW.logdate &gt;= DATE '2006-02-01' AND
         NEW.logdate &lt; DATE '2006-03-01' ) THEN
        INSERT INTO measurement_y2006m02 VALUES (NEW.*);
    ELSIF ( NEW.logdate &gt;= DATE '2006-03-01' AND
            NEW.logdate &lt; DATE '2006-04-01' ) THEN
        INSERT INTO measurement_y2006m03 VALUES (NEW.*);
    ...
    ELSIF ( NEW.logdate &gt;= DATE '2008-01-01' AND
            NEW.logdate &lt; DATE '2008-02-01' ) THEN
        INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION 'Date out of range.  Fix the measurement_insert_trigger() function!';
    END IF;
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>
        触发器的定义和以前一样。注意每一个<literal>IF</literal>测试必须准确地匹配它的分区的<literal>CHECK</literal>约束。
       </para>

       <para>
        当该函数比单月形式更加复杂时，并不需要频繁地更新它，因为可以在需要的时候提前加入分支。
       </para>

       <note>
        <para>
         在实践中，如果大部分插入都会进入最新的分区，最好先检查它。为了简洁，我们为触发器的检查采用了和本例中其他部分一致的顺序。
        </para>
       </note>

    <para>
     另一种将插入重定向到合适的分区表的方法是在主表上建立规则而不是触发器，例如：

<programlisting>
CREATE RULE measurement_insert_y2006m02 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
DO INSTEAD
    INSERT INTO measurement_y2006m02 VALUES (NEW.*);
...
CREATE RULE measurement_insert_y2008m01 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
DO INSTEAD
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
</programlisting>

     一个规则比一个触发器具有明显更高的负荷，但是该负荷是由每个查询承担而不是每一个行，因此这种方法可能对于批量插入的情况有益。但是，在大部分情况下触发器方法能提供更好的性能。
    </para>
    <para>
     注意<command>COPY</>会忽略规则。如果希望使用<command>COPY</>来插入数据，我们将希望将数据复制到正确的分区表而不是主表。<command>COPY</>会引发触发器，因此如果使用触发器方法就可以正常地使用它。
    </para>

    <para>
     规则方法的另一个缺点是如果一组规则没有覆盖被插入的数据，则该数据将被插入到主表中而不会发出任何错误。
    </para>
       </listitem>
	
       <listitem>
        <para>
         确保<filename>postgresql.conf</>没有禁用
		 <xref linkend="guc-constraint-exclusion">
         配置参数。如果禁用了，查询将不会根据需要进行优化。
        </para>
	   </listitem>
     </orderedlist>
    </para>

    <para>
     如我们所见，一个复杂的划分模式可能需要大量的DDL。在上面的例子中，我们需要每月创建一个新分区，所以最好能够编写一个脚本自动地生成所需的DDL。
    </para>

    </sect3>

    <sect3 id="ddl-partitioning-inheritance-maintenance">
     <title>分区维护</title>
     <para>
      要快速移除老旧数据，只需要删除不再需要的分区：
<programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
     </para>
    <para>
     要从分区表中删除分区，但保留对其自身权限的访问：

<programlisting>
ALTER TABLE measurement_y2006m02 NO INHERIT measurement;
</programlisting>
    </para>
	 <para>
     要添加新分区来处理新数据，请创建一个空分区，就像上面创建原始分区一样：

<programlisting>
CREATE TABLE measurement_y2008m02 (
    CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' )
) INHERITS (measurement);
</programlisting>

     可选择的，有人可能想要一个在分区结构之外创建新表，
	 并且在数据被载入、检查和转换之后使其成为分区：

<programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );
\copy measurement_y2008m02 from 'measurement_y2008m02'
-- 可能做一些其他数据准备工作


ALTER TABLE measurement_y2008m02 INHERIT measurement;
</programlisting>
    </para>


   </sect3>


   <sect3 id="ddl-partitioning-inheritance-caveats">
    <title>警告</title>
    <para>
     以下注意事项适用于使用继承实现的分区表：
     <itemizedlist>
      <listitem>
       <para>
        没有自动的方法来验证所有的<literal>CHECK</literal>约束是相互排斥的。
		创建生成分区并创建和/或修改关联对象的代码比手工编写每个代码更安全。
       </para>
      </listitem>

      <listitem>
       <para>
        这里显示的方案假定行的分区键列不会改变，或者至少不会变化太大
		以至于需要移动到另一个分区。一个试图这样做的<command>UPDATE</>
		会因为<literal>CHECK</>约束而失败。如果您需要处理这种情况，
		可以在分区表上放置合适的更新触发器，但这会使结构的管理更为复杂。
       </para>
      </listitem>

      <listitem>
       <para>
        If you are using manual <command>VACUUM</command> or
        <command>ANALYZE</command> commands, don't forget that
        you need to run them on each partition individually. A command like:
		如果您正在手动使用<command>VACUUM</command>或
		<command>ANALYZE</command>命令，
		请不要忘记您需要分别在每个分区上运行它们。像这样的命令：
<programlisting>
ANALYZE measurement;
</programlisting>
        将只处理主表。
       </para>
      </listitem>

      <listitem>
       <para>
        使用<literal>ON CONFLICT</>子句的<command>INSERT</command>
		语句不可能像预期的那样工作，因为<literal>ON CONFLICT</>
		仅在指定的目标关系、而不是它的子关系上违反唯一约束时采取动作。
       </para>
      </listitem>


      <listitem>
       <para>
        除非应用程序明确知道分区方案，
		否则需要触发器或规则将行分配到期望的分区。触发器编写起来可能很复杂，
		并且比声明式分区内部执行的元组分配要慢得多。
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect3>
  </sect2>
   <sect2 id="ddl-partitioning-constraint-exclusion">
   <title>划分和约束排除</title>

   <indexterm>
    <primary>constraint exclusion</primary>
   </indexterm>

   <para>
    <firstterm>约束排除</>是一种查询优化技术，它可以为按照以上方式定义的被划分表提高性能（声明式分区表和使用继承实现的分区表）。例如：

<programlisting>
SET constraint_exclusion = on;
SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
</programlisting>

    如果没有约束排除，上述查询将扫描<structname>measurement</>表的每一个分区。在启用约束排除后，规划器将检查每一个分区的约束来确定该分区需不需要被扫描，因为分区中可能不包含满足查询<literal>WHERE</>子句的行。如果规划器能够证实这一点，则它将会把该分区排除在查询计划之外。
   </para>

   <para>
    可以使用<command>EXPLAIN</>命令来显示开启了<varname>constraint_exclusion</>的计划和没有开启该选项的计划之间的区别。一个典型的未优化的计划是：

<programlisting>
SET constraint_exclusion = off;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';

                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Aggregate  (cost=158.66..158.68 rows=1 width=0)
   -&gt;  Append  (cost=0.00..151.88 rows=2715 width=0)
         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m02 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m03 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
...
         -&gt;  Seq Scan on measurement_y2007m12 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>

    其中的某些或者全部分区将会使用索引扫描而不是全表顺序扫描，但是关键在于根本不需要扫描旧分区来回答这个查询。当我们开启约束排除后，对于同一个查询我们会得到一个更加廉价的计划：

<programlisting>
SET constraint_exclusion = on;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Aggregate  (cost=63.47..63.48 rows=1 width=0)
   -&gt;  Append  (cost=0.00..60.75 rows=1086 width=0)
         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>
   </para>

   <para>
    注意约束排除只由<literal>CHECK</>约束驱动，而非索引的存在。因此，没有必要在关键列上定义索引。是否在给定分区上定义索引取决于我们希望查询经常扫描表的大部分还是小部分。在后一种情况中索引将会发挥作用。
   </para>

   <para>
    <xref linkend="guc-constraint-exclusion">的默认（也是推荐）设置实际上既不是<literal>on</>也不是<literal>off</>，而是一个被称为<literal>partition</>的中间设置，这使得该技术只被应用于将要在被分区表上工作的查询。设置<literal>on</>将使得规划器在所有的查询中检查<literal>CHECK</>约束，即使简单查询不会从中受益。
   </para>

   <para>
    以下注意事项适用于继承和分区表使用的约束排除：

   <itemizedlist>
    <listitem>
     <para>
      只有在查询的<literal>WHERE</>子句包含常量（或者外部提供的参数）时，约束排除才会起效。例如，一个与非不变函数（例如<function>CURRENT_TIMESTAMP</function>）的比较不能被优化，因为规划器不知道该函数的值在运行时会落到哪个分区内。
     </para>
    </listitem>

    <listitem>
     <para>
      保持划分约束简单，否则规划器可能没有办法验证无需访问的分区。按前面的例子所示，为列表划分使用简单相等条件或者为范围划分使用简单范围测试。
	  一个很好的经验法则是分区约束应该只包含使用B-tree索引操作符的分区列与常量的比较，
	  这甚至适用于分区表，因为只允许B-tree索引列在分区键中。（这在使用声明式分区时不是问题，
	  因为自动生成的约束非常简单，可以被规划器理解。）
     </para>
    </listitem>

    <listitem>
     <para>
      在约束排除期间，主表所有的分区上的所有约束都会被检查，所以大量的分区将会显著地增加查询规划时间。使用这些技术的划分在大约最多100个分区的情况下工作得很好，但是不要尝试使用成千个分区。
     </para>
    </listitem>

   </itemizedlist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-foreign-data">
  <title>外部数据</title>

   <indexterm>
    <primary>foreign data</primary>
   </indexterm>
   <indexterm>
    <primary>foreign table</primary>
   </indexterm>
   <indexterm>
    <primary>user mapping</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname>实现了部分的SQL/MED规定，允许我们使用普通SQL查询来访问位于PostgreSQL之外的数据。这种数据被称为<firstterm>外部数据</>（注意这种用法不要和外键混淆，后者是数据库中的一种约束）。
   </para>

   <para>
    外部数据可以在一个<firstterm>外部数据包装器</firstterm>的帮助下被访问。一个外部数据包装器是一个库，它可以与一个外部数据源通讯，并隐藏连接到数据源和从它获取数据的细节。在<filename>contrib</>模块中有一些外部数据包装器，参见<xref linkend="contrib">。其他类型的外部数据包装器可以在第三方产品中找到。如果这些现有的外部数据包装器都不能满足你的需要，可以自己编写一个，参见<xref linkend="fdwhandler">。
   </para>

   <para>
    要访问外部数据，我们需要建立一个<firstterm>外部服务器</>对象，它根据它所支持的外部数据包装器所使用的一组选项定义了如何连接到一个特定的外部数据源。接着我们需要创建一个或多个<firstterm>外部表</firstterm>，它们定义了外部数据的结构。一个外部表可以在查询中像一个普通表一样地使用，但是在PostgreSQL服务器中外部表没有存储数据。不管使用什么外部数据包装器，<productname>PostgreSQL</productname>会要求外部数据包装器从外部数据源获取数据，或者在更新命令的情况下传送数据到外部数据源。
   </para>

   <para>
    访问远程数据可能需要在外部数据源的授权。这些信息通过一个<firstterm>用户映射</>提供，它基于当前的<productname>PostgreSQL</productname>角色提供了附加的数据例如用户名和密码。
   </para>

   <para>
    更多信息请见
    <xref linkend="sql-createforeigndatawrapper">、
    <xref linkend="sql-createserver">、
    <xref linkend="sql-createusermapping">、
    <xref linkend="sql-createforeigntable">以及
    <xref linkend="sql-importforeignschema">。
   </para>
 </sect1>

 <sect1 id="ddl-others">
  <title>其他数据库对象</title>

  <para>
   表是一个关系型数据库结构中的核心对象，因为它们承载了我们的数据。但是它们并不是数据库中的唯一一种对象。有很多其他种类的对象可以被创建来使得数据的使用和刮泥更加方便或高效。在本章中不会讨论它们，但是我们在会给出一个列表：
  </para>

  <itemizedlist>
   <listitem>
    <para>
     视图
    </para>
   </listitem>

   <listitem>
    <para>
     函数和操作符
    </para>
   </listitem>

   <listitem>
    <para>
     数据类型和域
    </para>
   </listitem>

   <listitem>
    <para>
     触发器和重写规则
    </para>
   </listitem>
  </itemizedlist>

  <para>
   这些主题的详细信息请见<xref linkend="server-programming">。
  </para>
 </sect1>

 <sect1 id="ddl-depend">
  <title>依赖跟踪</title>

  <indexterm zone="ddl-depend">
   <primary>CASCADE</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>

  <indexterm zone="ddl-depend">
   <primary>RESTRICT</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>

  <para>
   当我们创建一个涉及到很多具有外键约束、视图、触发器、函数等的表的复杂数据库结构时，我们隐式地创建了一张对象之间的依赖关系网。例如，具有一个外键约束的表依赖于它所引用的表。
  </para>

  <para>
   为了保证整个数据库结构的完整性，<productname>PostgreSQL</productname>确保我们无法删除仍然被其他对象依赖的对象。例如，尝试删除<xref linkend="ddl-constraints-fk">中的产品表会导致一个如下的错误消息，因为有订单表依赖于产品表：
<screen>
DROP TABLE products;

ERROR:  cannot drop table products because other objects depend on it
DETAIL:  constraint orders_product_no_fkey on table orders depends on table products
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
</screen>
   该错误消息包含了一个有用的提示：如果我们不想一个一个去删除所有的依赖对象，我们可以执行：
<screen>
DROP TABLE products CASCADE;
</screen>
   这样所有的依赖对象将被移除，同样依赖于它们的任何对象也会被递归删除。在这种情况下，订单表不会被移除，但是它的外键约束会被移除。之所以在这里会停下，是因为没有什么依赖着外键约束（如果希望检查<command>DROP ... CASCADE</>会干什么，运行不带<literal>CASCADE</>的<command>DROP</>并阅读<literal>DETAIL</>输出）。
  </para>

  <para>
   <productname>PostgreSQL</productname>中的几乎所有<command>DROP</>命令都支持<literal>CASCADE</literal>。当然，其本质的区别随着对象的类型而不同。我们也可以用<literal>RESTRICT</literal>代替<literal>CASCADE</literal>来获得默认行为，它将阻止删除任何被其他对象依赖的对象。
  </para>

  <note>
   <para>
    根据SQL标准，在<command>DROP</>命令中指定<literal>RESTRICT</literal>或<literal>CASCADE</literal>是被要求的。但没有哪个数据库系统真正强制了这个规则，但是不同的系统中两种默认行为都是可能的。
   </para>
  </note>

  <para>
   如果一个<command>DROP</>命令列出了多个对象，只有在存在指定对象构成的组之外的依赖关系时才需要<literal>CASCADE</literal>。例如，如果发出命令<literal>DROP TABLE tab1, tab2</literal>且存在从<literal>tab2</>到<literal>tab1</>的外键引用，那么就不需要<literal>CASCADE</literal>即可成功执行。
  </para>

  <para>
   对于用户定义的函数，<productname>PostgreSQL</productname>会追踪与函数外部可见性质相关的依赖性，例如它的参数和结果类型，但<emphasis>不</>追踪检查函数体才能知道的依赖性。例如，考虑这种情况：

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow',
                             'green', 'blue', 'purple');

CREATE TABLE my_colors (color rainbow, note text);

CREATE FUNCTION get_color_note (rainbow) RETURNS text AS
  'SELECT note FROM my_colors WHERE color = $1'
  LANGUAGE SQL;
</programlisting>

   （SQL 元函数的解释见<xref linkend="xfunc-sql">）。<productname>PostgreSQL</productname>将会注意到<function>get_color_note</>函数依赖于<type>rainbow</>类型：删掉该类型会强制删除该函数，因为该函数的参数类型就无法定义了。但是<productname>PostgreSQL</>不会认为<function>get_color_note</>依赖于<structname>my_colors</>表，因此即使该表被删除也不会删除这个函数。虽然这种方法有缺点，但是也有好处。如果该表丢失，这个函数在某种程度上仍然是有效的，但是执行它会导致错误。创建一个同名的新表将允许该函数重新有效。
  </para>
 </sect1>

</chapter>
