<!-- doc/src/sgml/trigger.sgml -->

 <chapter id="triggers">
<!--==========================orignal english content==========================
  <title>Triggers</title>
____________________________________________________________________________-->
  <title>触发器</title>

<!--==========================orignal english content==========================
  <indexterm zone="triggers">
   <primary>trigger</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="triggers">
   <primary>trigger</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   This chapter provides general information about writing trigger functions.
   Trigger functions can be written in most of the available procedural
   languages, including
   <application>PL/pgSQL</application> (<xref linkend="plpgsql">),
   <application>PL/Tcl</application> (<xref linkend="pltcl">),
   <application>PL/Perl</application> (<xref linkend="plperl">), and
   <application>PL/Python</application> (<xref linkend="plpython">).
   After reading this chapter, you should consult the chapter for
   your favorite procedural language to find out the language-specific
   details of writing a trigger in it.
  </para>
____________________________________________________________________________-->
  <para>
   本章提供了编写触发器函数的一般信息。触发器函数可以使用大部分可用过程性语言，包括
   <application>PL/pgSQL</application>（<xref linkend="plpgsql">）、
   <application>PL/Tcl</application>（<xref linkend="pltcl">）、
   <application>PL/Perl</application>（<xref linkend="plperl">）和
   <application>PL/Python</application>（<xref linkend="plpython">)。阅读本章后，你应该查阅你喜欢的过程性语言来找到用其编写触发器的相关细节。
  </para>

<!--==========================orignal english content==========================
  <para>
   It is also possible to write a trigger function in C, although
   most people find it easier to use one of the procedural languages.
   It is not currently possible to write a trigger function in the
   plain SQL function language.
  </para>
____________________________________________________________________________-->
  <para>
   也可以使用C编写一个触发器函数，尽管大部分人觉得使用一种过程性语言更简单。当前不能用纯SQL函数语言来编写触发器函数。
  </para>

  <sect1 id="trigger-definition">
<!--==========================orignal english content==========================
   <title>Overview of Trigger Behavior</title>
____________________________________________________________________________-->
   <title>触发器行为概述</title>

<!--==========================orignal english content==========================
   <para>
    A trigger is a specification that the database should automatically
    execute a particular function whenever a certain type of operation is
    performed.  Triggers can be attached to tables (partitioned or not),
    views, and foreign tables.
  </para>
____________________________________________________________________________-->
   <para>
    一个触发器声明了当执行一种特定类型的操作时数据库应该自动执行一个特殊的函数。触发器可以被附加到表（分区或不分区）、视图和外部表。
  </para>

<!--==========================orignal english content==========================
  <para>
    On tables and foreign tables, triggers can be defined to execute either
    before or after any <command>INSERT</command>, <command>UPDATE</command>,
    or <command>DELETE</command> operation, either once per modified row,
    or once per <acronym>SQL</acronym> statement.
    <command>UPDATE</command> triggers can moreover be set to fire only if
    certain columns are mentioned in the <literal>SET</literal> clause of
    the <command>UPDATE</command> statement.  Triggers can also fire
    for <command>TRUNCATE</command> statements.  If a trigger event occurs,
    the trigger's function is called at the appropriate time to handle the
    event.
   </para>
____________________________________________________________________________-->
  <para>
    在表和外部表上，触发器可以被定义为在
    <command>INSERT</command>、<command>UPDATE</command>或
   <command>DELETE</command>操作之前或之后被执行，
   可以为每个<acronym>SQL</acronym>语句被执行一次或者为每个修改的行
   被执行一次。<command>UPDATE</command>
    触发器可以进一步地设置为只针对<command>UPDATE</command>
    语句的<literal>SET</literal>子句的特定列出发。触发器也可以被
    <command>TRUNCATE</command>语句触发。如果一个触发器事件发生，
    触发器函数会在适当的事件被调用来处理该事件。
   </para>

<!--==========================orignal english content==========================
   <para>
    On views, triggers can be defined to execute instead of
    <command>INSERT</command>, <command>UPDATE</command>, or
    <command>DELETE</command> operations.  <literal>INSTEAD OF</> triggers
    are fired once for each row that needs to be modified in the view.
    It is the responsibility of the
    trigger's function to perform the necessary modifications to the
    underlying base tables and, where appropriate, return the modified
    row as it will appear in the view.  Triggers on views can also be defined
    to execute once per <acronym>SQL</acronym> statement, before or after
    <command>INSERT</command>, <command>UPDATE</command>, or
    <command>DELETE</command> operations.
   </para>
____________________________________________________________________________-->
   <para>
    在视图上，触发器可以被定义来取代<command>INSERT</command>、<command>UPDATE</command>或
    <command>DELETE</command>操作的执行。<literal>INSTEAD OF</>触发器对视图中需要被修改的每一行触发一次。触发器函数的职责是对底层的基本表执行必要的修改，并且在合适的时候返回被修改的行以便显示在视图中。视图上的触发器也可以被定义为对每个<acronym>SQL</acronym>语句执行一次，在<command>INSERT</command>\<command>UPDATE</command>或<command>DELETE</command>操作之前或之后。
   </para>

<!--==========================orignal english content==========================
   <para>
    The trigger function must be defined before the trigger itself can be
    created.  The trigger function must be declared as a
    function taking no arguments and returning type <literal>trigger</>.
    (The trigger function receives its input through a specially-passed
    <structname>TriggerData</> structure, not in the form of ordinary function
    arguments.)
   </para>
____________________________________________________________________________-->
   <para>
    触发器函数必须在触发器本身被创建之前被定义好。触发器函数必须被定义成一个没有参数的函数，并且返回类型为<literal>trigger</>（触发器函数通过一个特殊传递的<structname>TriggerData</>结构作为其输入，而不是以普通函数参数的形式）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Once a suitable trigger function has been created, the trigger is
    established with
    <xref linkend="sql-createtrigger">.
    The same trigger function can be used for multiple triggers.
   </para>
____________________________________________________________________________-->
   <para>
    一旦一个合适的触发器函数被创建，就可以使用<xref linkend="sql-createtrigger">建立触发器。同一个触发器函数可以被用于多个触发器。
   </para>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> offers both <firstterm>per-row</>
    triggers and <firstterm>per-statement</> triggers.  With a per-row
    trigger, the trigger function
    is invoked once for each row that is affected by the statement
    that fired the trigger. In contrast, a per-statement trigger is
    invoked only once when an appropriate statement is executed,
    regardless of the number of rows affected by that statement. In
    particular, a statement that affects zero rows will still result
    in the execution of any applicable per-statement triggers. These
    two types of triggers are sometimes called <firstterm>row-level</>
    triggers and <firstterm>statement-level</> triggers,
    respectively. Triggers on <command>TRUNCATE</command> may only be
    defined at statement level, not per-row.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>同时提供<firstterm>每行的</>触发器和<firstterm>每语句的</>触发器。对于一个每行的触发器，对于触发触发器的语句所修改的每一行都会调用一次触发器函数。相反，一个每语句的触发器对于其触发语句只被调用一次，而不管该语句影响了多少行。特别地，一个不影响任何行的语句仍然会导致任何可用每语句的触发器的执行。这两类触发器有时也分别被称作<firstterm>行级</>触发器和<firstterm>语句级</>触发器。
	<command>TRUNCATE</command>上的触发器只能定义在语句级，而不是每行定义。
   </para>

<!--==========================orignal english content==========================
   <para>
    Triggers are also classified according to whether they fire
    <firstterm>before</>, <firstterm>after</>, or
    <firstterm>instead of</> the operation. These are referred to
    as <literal>BEFORE</> triggers, <literal>AFTER</> triggers, and
    <literal>INSTEAD OF</> triggers respectively.
    Statement-level <literal>BEFORE</> triggers naturally fire before the
    statement starts to do anything, while statement-level <literal>AFTER</>
    triggers fire at the very end of the statement.  These types of
    triggers may be defined on tables, views, or foreign tables.  Row-level
    <literal>BEFORE</> triggers fire immediately before a particular row is
    operated on, while row-level <literal>AFTER</> triggers fire at the end of
    the statement (but before any statement-level <literal>AFTER</> triggers).
    These types of triggers may only be defined on non-partitioned tables and
    foreign tables, not views.  <literal>INSTEAD OF</> triggers may only be
    defined on views, and only at row level; they fire immediately as each
    row in the view is identified as needing to be operated on.
   </para>
____________________________________________________________________________-->
   <para>
    触发器也可以根据它们是否在操作<firstterm>之前</>、<firstterm>之后</>触发，
	或者被触发来<firstterm>取代</>操作来分类。它们分别指<literal>BEFORE</>触发器、
	<literal>AFTER</> 触发器以及<literal>INSTEAD OF</>触发器。语句级<literal>BEFORE</>
	触发器在语句开始做任何事情之前被触发，而语句级<literal>AFTER</>触发器则在语句做完所有事情之后被触发。
	这些触发器类型可以被定义在表、视图或外部表上。行级<literal>BEFORE</>触发器在每一个行被操作之前被触发，
	而行级<literal>AFTER</>触发器在语句结束之后被触发（但在任何语句级<literal>AFTER</>触发器之前）。
	这些触发器类型只能被定义在非分区表和外部表上，不能定义在视图上。<literal>INSTEAD OF</>
	触发器只能被定义在视图上，并且只能定义为行级；
	它们立刻为视图中每一个被标识为需要被操作的行触发。
   </para>

<!--==========================orignal english content==========================
   <para>
    A statement that targets a parent table in an inheritance or partitioning
    hierarchy does not cause the statement-level triggers of affected child
    tables to be fired; only the parent table's statement-level triggers are
    fired.  However, row-level triggers of any affected child tables will be
    fired.
   </para>
____________________________________________________________________________-->
   <para>
    在继承或分区层次结构中定位父表的语句不会导致受影响的子表的语句级触发器被触发；
	只有父表的语句级触发器被触发。但是，任何受影响的子表的行级触发器都将被触发。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    If an <command>INSERT</command> contains an <literal>ON CONFLICT
    DO UPDATE</> clause, it is possible that the effects of
    row-level <literal>BEFORE</> <command>INSERT</command> triggers and
    row-level <literal>BEFORE</literal> <command>UPDATE</command> triggers can
    both be applied in a way that is apparent from the final state of
    the updated row, if an <varname>EXCLUDED</> column is referenced.
    There need not be an <varname>EXCLUDED</> column reference for
    both sets of row-level <literal>BEFORE</literal> triggers to execute,
    though.  The
    possibility of surprising outcomes should be considered when there
    are both <literal>BEFORE</> <command>INSERT</command> and
    <literal>BEFORE</> <command>UPDATE</command> row-level triggers
    that change a row being inserted/updated (this can be
    problematic even if the modifications are more or less equivalent, if
    they're not also idempotent).  Note that statement-level
    <command>UPDATE</command> triggers are executed when <literal>ON
    CONFLICT DO UPDATE</> is specified, regardless of whether or not
    any rows were affected by the <command>UPDATE</command> (and
    regardless of whether the alternative <command>UPDATE</command>
    path was ever taken).  An <command>INSERT</command> with an
    <literal>ON CONFLICT DO UPDATE</> clause will execute
    statement-level <literal>BEFORE</> <command>INSERT</command>
    triggers first, then statement-level <literal>BEFORE</>
    <command>UPDATE</command> triggers, followed by statement-level
    <literal>AFTER</> <command>UPDATE</command> triggers and finally
    statement-level <literal>AFTER</> <command>INSERT</command>
    triggers.
   </para>
____________________________________________________________________________-->
   <para>
    如果一个<command>INSERT</command>包含<literal>ON CONFLICT
    DO UPDATE</>子句并且引用了<varname>EXCLUDED</>列，有可能行级
    <literal>BEFORE</> <command>INSERT</command>触发器和行级
    <literal>BEFORE</literal> <command>UPDATE</command>触发器的效果可能会以一种对于
    被更新行最终状态透明的方式被应用。不过，对于要执行的两种集合的行级
    <literal>BEFORE</literal>触发器都不需要有<varname>EXCLUDED</>列引用。当同时有行级
    <literal>BEFORE</> <command>INSERT</command>和
    <literal>BEFORE</> <command>UPDATE</command>触发器修改被插入/
    更新的行时（即使修改或多或少都具有同等效力，但如果它们也不是幂等的，这可能会有问题），
    应该考虑可能出现的意料之外的结果。注意在指定了
    <literal>ON CONFLICT DO UPDATE</>时，不管有没有行被
    <command>UPDATE</command>影响（并且不管是否采用了其他
    <command>UPDATE</command>路径），语句级
    <command>UPDATE</command>都将被执行。一个带有
    <literal>ON CONFLICT DO UPDATE</>子句的<command>INSERT</command>
    将首先执行语句级<literal>BEFORE</> <command>INSERT</command>，
    然后执行语句级<literal>BEFORE</>
    <command>UPDATE</command>触发器，
    接着是语句级<literal>AFTER</> <command>UPDATE</command>触发器，
    最后是语句级<literal>AFTER</> <command>INSERT</command>触发器。
   </para>

<!--==========================orignal english content==========================
   <para>
    Trigger functions invoked by per-statement triggers should always
    return <symbol>NULL</symbol>. Trigger functions invoked by per-row
    triggers can return a table row (a value of
    type <structname>HeapTuple</structname>) to the calling executor,
    if they choose.  A row-level trigger fired before an operation has
    the following choices:

    <itemizedlist>
     <listitem>
      <para>
       It can return <symbol>NULL</> to skip the operation for the
       current row. This instructs the executor to not perform the
       row-level operation that invoked the trigger (the insertion,
       modification, or deletion of a particular table row).
      </para>
     </listitem>

     <listitem>
      <para>
       For row-level <command>INSERT</command>
       and <command>UPDATE</command> triggers only, the returned row
       becomes the row that will be inserted or will replace the row
       being updated.  This allows the trigger function to modify the
       row being inserted or updated.
      </para>
     </listitem>
    </itemizedlist>

    A row-level <literal>BEFORE</> trigger that does not intend to cause
    either of these behaviors must be careful to return as its result the same
    row that was passed in (that is, the <varname>NEW</varname> row
    for <command>INSERT</command> and <command>UPDATE</command>
    triggers, the <varname>OLD</varname> row for
    <command>DELETE</command> triggers).
   </para>
____________________________________________________________________________-->
   <para>
    被语句级触发器调用的触发器函数应该总是返回<symbol>NULL</symbol>。根据行级触发器的选择，被其调用的触发器函数可以返回一个表行（类型<structname>HeapTuple</structname>的一个值）给执行器。在一个操作前触发的行级触发器有下列选择：

    <itemizedlist>
     <listitem>
      <para>
       它可以返回<symbol>NULL</>来跳过对当前行的操作。这指示执行器不要执行调用触发器的行级操作（对一个特定表行的插入、修改或删除）。
      </para>
     </listitem>

     <listitem>
      <para>
       仅对行级<command>INSERT</command>和<command>UPDATE</command>触发器来说，被返回的行称为将要被插入的行或者替代将被更新的行。这允许触发器函数修改将要被插入或更新的行。
      </para>
     </listitem>
    </itemizedlist>

    一个无意导致任何这些行为的行级<literal>BEFORE</>触发器必须小心地它的结果，使之和被传入的行一样（即，<command>INSERT</command>和<command>UPDATE</command>触发器的<varname>NEW</varname>行，<command>DELETE</command>触发器的<varname>OLD</varname>行）。
   </para>

<!--==========================orignal english content==========================
   <para>
    A row-level <literal>INSTEAD OF</> trigger should either return
    <symbol>NULL</> to indicate that it did not modify any data from
    the view's underlying base tables, or it should return the view
    row that was passed in (the <varname>NEW</varname> row
    for <command>INSERT</command> and <command>UPDATE</command>
    operations, or the <varname>OLD</varname> row for
    <command>DELETE</command> operations). A nonnull return value is
    used to signal that the trigger performed the necessary data
    modifications in the view.  This will cause the count of the number
    of rows affected by the command to be incremented. For
    <command>INSERT</> and <command>UPDATE</> operations, the trigger
    may modify the <varname>NEW</> row before returning it.  This will
    change the data returned by
    <command>INSERT RETURNING</> or <command>UPDATE RETURNING</>,
    and is useful when the view will not show exactly the same data
    that was provided.
   </para>
____________________________________________________________________________-->
   <para>
    一个行级<literal>INSTEAD OF</>触发器可以返回<symbol>NULL</>来指示它没有修改任何来自于视图底层基表的数据，也可以返回被传入的视图行（<command>INSERT</command>和<command>UPDATE</command>操作的<varname>NEW</varname>行，或者<command>DELETE</command>操作的<varname>OLD</varname>行）。一个非空返回值被用于标志触发器在视图中执行了必须的数据修改。这将会导致被命令修改的行计数被增加。对于<command>INSERT</>和<command>UPDATE</>操作，触发器可能会在返回<varname>NEW</>行之前对其进行修改。这将会改变<command>INSERT RETURNING</>或<command>UPDATE RETURNING</>返回的数据，并在视图无法正确地显示提供给它的相同数据时有用。
   </para>

<!--==========================orignal english content==========================
   <para>
    The return value is ignored for row-level triggers fired after an
    operation, and so they can return <symbol>NULL</>.
   </para>
____________________________________________________________________________-->
   <para>
    对于在一个操作之后触发的行级触发器，返回值会被忽略，因此它们可以返回<symbol>NULL</>。
   </para>

<!--==========================orignal english content==========================
   <para>
    If more than one trigger is defined for the same event on the same
    relation, the triggers will be fired in alphabetical order by
    trigger name.  In the case of <literal>BEFORE</> and
    <literal>INSTEAD OF</> triggers, the possibly-modified row returned by
    each trigger becomes the input to the next trigger.  If any
    <literal>BEFORE</> or <literal>INSTEAD OF</> trigger returns
    <symbol>NULL</>, the operation is abandoned for that row and subsequent
    triggers are not fired (for that row).
   </para>
____________________________________________________________________________-->
   <para>
    如果为同一个关系上的同一事件定义了超过一个触发器，它们将按照其名称的字母表顺序被触发。在<literal>BEFORE</>和<literal>INSTEAD OF</>触发器的情况下，每一个触发器返回的可能被修改的行将成为下一个触发器的输入。如果任何一个<literal>BEFORE</>或<literal>INSTEAD OF</>触发器返回<symbol>NULL</>，该操作将在该行上被禁用并且对于该行不会触发后续的触发器。
   </para>

<!--==========================orignal english content==========================
   <para>
    A trigger definition can also specify a Boolean <literal>WHEN</>
    condition, which will be tested to see whether the trigger should
    be fired.  In row-level triggers the <literal>WHEN</> condition can
    examine the old and/or new values of columns of the row.  (Statement-level
    triggers can also have <literal>WHEN</> conditions, although the feature
    is not so useful for them.)  In a <literal>BEFORE</> trigger, the
    <literal>WHEN</>
    condition is evaluated just before the function is or would be executed,
    so using <literal>WHEN</> is not materially different from testing the
    same condition at the beginning of the trigger function.  However, in
    an <literal>AFTER</> trigger, the <literal>WHEN</> condition is evaluated
    just after the row update occurs, and it determines whether an event is
    queued to fire the trigger at the end of statement.  So when an
    <literal>AFTER</> trigger's
    <literal>WHEN</> condition does not return true, it is not necessary
    to queue an event nor to re-fetch the row at end of statement.  This
    can result in significant speedups in statements that modify many
    rows, if the trigger only needs to be fired for a few of the rows.
    <literal>INSTEAD OF</> triggers do not support
    <literal>WHEN</> conditions.
   </para>
____________________________________________________________________________-->
   <para>
    一个触发器定义也能指定一个布尔的<literal>WHEN</>条件，它将被测试来看该触发器是否应该被触发。在行级触发器中，<literal>WHEN</>条件可以检查该行的旧列值和/或新列值（语句级触发器也能有<literal>WHEN</>条件，但是该特性对它们不太有用）。在一个<literal>BEFORE</>触发器中，<literal>WHEN</>条件只是在该函数被或者将被执行前计算，因此使用<literal>WHEN</>条件与在该触发器函数的开始测试相同的条件没有本质区别。不过，在一个<literal>AFTER</>触发器中，<literal>WHEN</>条件只是在行更新发生之后被计算，并且它决定在语句的末尾一个事件是否被排队来触发该触发器。因此当一个<literal>AFTER</>触发器的<literal>WHEN</>不返回真时，在语句的末尾没有必要将一个事件进行排队，也没有必要重新取出该行。如果触发器只对少数行触发，这可以使得修改很多行的语句明显加快。<literal>INSTEAD OF</>触发器不支持<literal>WHEN</>条件。
   </para>

<!--==========================orignal english content==========================
   <para>
    Typically, row-level <literal>BEFORE</> triggers are used for checking or
    modifying the data that will be inserted or updated.  For example,
    a <literal>BEFORE</> trigger might be used to insert the current time into a
    <type>timestamp</type> column, or to check that two elements of the row are
    consistent. Row-level <literal>AFTER</> triggers are most sensibly
    used to propagate the updates to other tables, or make consistency
    checks against other tables.  The reason for this division of labor is
    that an <literal>AFTER</> trigger can be certain it is seeing the final
    value of the row, while a <literal>BEFORE</> trigger cannot; there might
    be other <literal>BEFORE</> triggers firing after it.  If you have no
    specific reason to make a trigger <literal>BEFORE</> or
    <literal>AFTER</>, the <literal>BEFORE</> case is more efficient, since
    the information about
    the operation doesn't have to be saved until end of statement.
   </para>
____________________________________________________________________________-->
   <para>
    通常，行级<literal>BEFORE</>被用来检查或修改即将被插入或更新的数据。例如，一个<literal>BEFORE</>触发器可以被用来把当前时间插入到一个<type>timestamp</type>列中，或者检查该行的两个元素之间是否一致。行级<literal>AFTER</>触发器大多数被用来将更新传播到其他表，或者针对其他表进行一致性检查。进行这种工作分工的原因是，一个<literal>AFTER</>触发器可以肯定它看到的是该行的最终值，而一个<literal>BEFORE</>触发器则不能，因为还可能有其他<literal>BEFORE</>触发器在它之后触发。如果你不知道让一个触发器是<literal>BEFORE</>或<literal>AFTER</>，则<literal>BEFORE</>形式更加有效，因为关于该操作的信息直到语句的末尾都不需要被保存。
   </para>

<!--==========================orignal english content==========================
   <para>
    If a trigger function executes SQL commands then these
    commands might fire triggers again. This is known as cascading
    triggers.  There is no direct limitation on the number of cascade
    levels.  It is possible for cascades to cause a recursive invocation
    of the same trigger; for example, an <command>INSERT</command>
    trigger might execute a command that inserts an additional row
    into the same table, causing the <command>INSERT</command> trigger
    to be fired again.  It is the trigger programmer's responsibility
    to avoid infinite recursion in such scenarios.
   </para>
____________________________________________________________________________-->
   <para>
    如果一个触发器函数执行 SQL 命令，则这些命令可能会再次引发触发器。这就是所谓的级联触发器。对于级联的层数没有直接的限制。级联有可能会导致对同一个触发器的递归调用。例如，一个<command>INSERT</command>触发器可能执行一个向同一个表插入一个额外行的命令，这就导致该<command>INSERT</command>触发器被再次引发。所以在这种情形下，触发器程序员应该负责避免无限递归。
   </para>

<!--==========================orignal english content==========================
   <para>
    <indexterm>
     <primary>trigger</>
     <secondary>arguments for trigger functions</>
    </indexterm>
    When a trigger is being defined, arguments can be specified for
    it. The purpose of including arguments in the
    trigger definition is to allow different triggers with similar
    requirements to call the same function.  As an example, there
    could be a generalized trigger function that takes as its
    arguments two column names and puts the current user in one and
    the current time stamp in the other.  Properly written, this
    trigger function would be independent of the specific table it is
    triggering on.  So the same function could be used for
    <command>INSERT</command> events on any table with suitable
    columns, to automatically track creation of records in a
    transaction table for example. It could also be used to track
    last-update events if defined as an <command>UPDATE</command>
    trigger.
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm>
     <primary>触发器</>
     <secondary>用于触发器函数的参数</>
    </indexterm>
    在定义一个触发器时，可以为它指定参数。在触发器定义中包括参数的目的是允许具有相似需求的不同触发器调用同一个函数。例如，可能有一个一般性的触发器函数，它需要两个列名作为参数，一个放当前用户而另一个放当前时间戳。在正确编写的情况下，这个触发器函数应该独立于它所触发的表。因此同一个函数可以被用于具有适当列的任意表上的<command>INSERT</command>事件，这样做的用途之一是可以自动追踪一个交易表中记录的创建。如果被定义成一个<command>UPDATE</command>触发器，它也可以被用来追踪最新的更新事件。
   </para>

<!--==========================orignal english content==========================
   <para>
    Each programming language that supports triggers has its own method
    for making the trigger input data available to the trigger function.
    This input data includes the type of trigger event (e.g.,
    <command>INSERT</command> or <command>UPDATE</command>) as well as any
    arguments that were listed in <command>CREATE TRIGGER</>.
    For a row-level trigger, the input data also includes the
    <varname>NEW</varname> row for <command>INSERT</command> and
    <command>UPDATE</command> triggers, and/or the <varname>OLD</varname> row
    for <command>UPDATE</command> and <command>DELETE</command> triggers.
   </para>
____________________________________________________________________________-->
   <para>
    每一种支持触发器的编程语言都有自己的方法来让触发器输入数据对触发器函数可用。这种输入数据包括触发器事件的类型（如<command>INSERT</command>或<command>UPDATE</command>）以及被列在<command>CREATE TRIGGER</>中的任何参数。对于一个行级触发器，输入数据还包括用于<command>INSERT</command>和<command>UPDATE</command>触发器的<varname>NEW</varname>行，和/或用于<command>UPDATE</command>和<command>DELETE</command>触发器的<varname>OLD</varname>行。
   </para>

<!--==========================orignal english content==========================
   <para>
    By default, statement-level triggers do not have any way to examine the
    individual row(s) modified by the statement.  But an <literal>AFTER
    STATEMENT</> trigger can request that <firstterm>transition tables</>
    be created to make the sets of affected rows available to the trigger.
    <literal>AFTER ROW</> triggers can also request transition tables, so
    that they can see the total changes in the table as well as the change in
    the individual row they are currently being fired for.  The method for
    examining the transition tables again depends on the programming language
    that is being used, but the typical approach is to make the transition
    tables act like read-only temporary tables that can be accessed by SQL
    commands issued within the trigger function.
   </para>
____________________________________________________________________________-->
   <para>
    默认的，语句级触发器没有任何方法检查被语句修改的单个行。
	但是<literal>AFTER STATEMENT</>触发器可以请求创建<firstterm>转换表</>
	以使受影响的行集可用于触发器。<literal>AFTER ROW</>触发器也可以请求转换表，
	以便他们可以看到表中的全部更改以及它们当前正在触发的单个行中的更改。
	再次检查转换表的方法取决于正在使用的编程语言，但典型方法是使转换表像只读临时表一样，
	可以通过触发器函数内发出的SQL命令访问。
   </para>

  </sect1>

  <sect1 id="trigger-datachanges">
<!--==========================orignal english content==========================
   <title>Visibility of Data Changes</title>
____________________________________________________________________________-->
   <title>数据改变的可见性</title>

<!--==========================orignal english content==========================
   <para>
    If you execute SQL commands in your trigger function, and these
    commands access the table that the trigger is for, then
    you need to be aware of the data visibility rules, because they determine
    whether these SQL commands will see the data change that the trigger
    is fired for.  Briefly:

    <itemizedlist>

     <listitem>
      <para>
       Statement-level triggers follow simple visibility rules: none of
       the changes made by a statement are visible to statement-level
       <literal>BEFORE</literal> triggers, whereas all
       modifications are visible to statement-level <literal>AFTER</>
       triggers.
      </para>
     </listitem>

     <listitem>
      <para>
       The data change (insertion, update, or deletion) causing the
       trigger to fire is naturally <emphasis>not</emphasis> visible
       to SQL commands executed in a row-level <literal>BEFORE</> trigger,
       because it hasn't happened yet.
      </para>
     </listitem>

     <listitem>
      <para>
       However, SQL commands executed in a row-level <literal>BEFORE</>
       trigger <emphasis>will</emphasis> see the effects of data
       changes for rows previously processed in the same outer
       command.  This requires caution, since the ordering of these
       change events is not in general predictable; a SQL command that
       affects multiple rows can visit the rows in any order.
      </para>
     </listitem>

     <listitem>
      <para>
       Similarly, a row-level <literal>INSTEAD OF</> trigger will see the
       effects of data changes made by previous firings of <literal>INSTEAD
       OF</> triggers in the same outer command.
      </para>
     </listitem>

     <listitem>
      <para>
       When a row-level <literal>AFTER</> trigger is fired, all data
       changes made
       by the outer command are already complete, and are visible to
       the invoked trigger function.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    如果你在你的触发器函数中执行 SQL 命令，并且这些命令会访问触发器所在的表，那么你需要注意数据可见性规则。因为这些规则决定了这些 SQL 命令是否将能看见引发触发器的数据改变。简单地：

    <itemizedlist>

     <listitem>
      <para>
       语句级触发器遵循简单的可见性规则：一个语句所作的改变对于语句级
       <literal>BEFORE</literal>触发器都不可见，而所有修改对于语句级
       <literal>AFTER</>触发器都是可见的。
      </para>
     </listitem>

     <listitem>
      <para>
       导致触发器被引发的数据更改（插入、更新或删除）自然对于在一个行级<literal>BEFORE</>触发器中执行的 SQL 命令<emphasis>不</emphasis>可见，因为它还没有发生。
      </para>
     </listitem>

     <listitem>
      <para>
       但是，在一个行级<literal>BEFORE</>触发器中执行的 SQL 命令<emphasis>将会</emphasis>看见之前在同一个外层命令中所作的数据更改的效果。这里需要小心，因为这些更改时间的顺序通常是不可预测的，一个影响多行的 SQL 命令可能以任何顺序访问这些行。
      </para>
     </listitem>

     <listitem>
      <para>
       类似地，一个行级<literal>INSTEAD OF</>触发器将会看见之前在同一个外层命令中<literal>INSTEAD OF</>触发器引发所作的数据更改。
      </para>
     </listitem>

     <listitem>
      <para>
       当一个行级<literal>AFTER</>触发器被引发时，所有由外层命令所作的数据更改已经完成，并且对于该被调用的触发器函数是可见的。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    If your trigger function is written in any of the standard procedural
    languages, then the above statements apply only if the function is
    declared <literal>VOLATILE</>.  Functions that are declared
    <literal>STABLE</> or <literal>IMMUTABLE</> will not see changes made by
    the calling command in any case.
   </para>
____________________________________________________________________________-->
   <para>
    如果你的触发器函数使用任何一种标准过程语言编写的，那么只有在该函数被声明为<literal>VOLATILE</>时上述陈述才适用。被声明为<literal>STABLE</>或<literal>IMMUTABLE</>的函数在任何情况下将不能看到由调用命令所作出的更改。
   </para>

<!--==========================orignal english content==========================
   <para>
    Further information about data visibility rules can be found in
    <xref linkend="spi-visibility">.  The example in <xref
    linkend="trigger-example"> contains a demonstration of these rules.
   </para>
____________________________________________________________________________-->
   <para>
    有关数据可见性规则的更多信息可见<xref linkend="spi-visibility">。<xref linkend="trigger-example">中的例子包含了对这些规则的示范。
   </para>
  </sect1>

  <sect1 id="trigger-interface">
<!--==========================orignal english content==========================
   <title>Writing Trigger Functions in C</title>
____________________________________________________________________________-->
   <title>用 C 编写触发器函数</title>

<!--==========================orignal english content==========================
   <indexterm zone="trigger-interface">
    <primary>trigger</primary>
    <secondary>in C</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="trigger-interface">
    <primary>触发器</primary>
    <secondary>C</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>transition tables</primary>
    <secondary>referencing from C trigger</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>转换表</primary>
    <secondary>从C触发引用</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    This section describes the low-level details of the interface to a
    trigger function.  This information is only needed when writing
    trigger functions in C.  If you are using a higher-level language then
    these details are handled for you.  In most cases you should consider
    using a procedural language before writing your triggers in C.  The
    documentation of each procedural language explains how to write a
    trigger in that language.
   </para>
____________________________________________________________________________-->
   <para>
    这一节描述了一个触发器函数的接口的低层细节。只有用 C 编写触发器函数时才需要这些信息。如果你使用一种更高层的语言，那么这些细节就不需要你来处理。在大部分情况下，你应该优先考虑使用一种过程语言。每一种过程语言的文档阐述了如何使用那种语言编写一个触发器。
   </para>

<!--==========================orignal english content==========================
   <para>
    Trigger functions must use the <quote>version 1</> function manager
    interface.
   </para>
____________________________________________________________________________-->
   <para>
    触发器函数必须使用<quote>版本 1</>函数管理器接口。
   </para>

<!--==========================orignal english content==========================
   <para>
    When a function is called by the trigger manager, it is not passed
    any normal arguments, but it is passed a <quote>context</>
    pointer pointing to a <structname>TriggerData</> structure.  C
    functions can check whether they were called from the trigger
    manager or not by executing the macro:
<programlisting>
CALLED_AS_TRIGGER(fcinfo)
</programlisting>
    which expands to:
<programlisting>
((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))
</programlisting>
    If this returns true, then it is safe to cast
    <literal>fcinfo-&gt;context</> to type <literal>TriggerData
    *</literal> and make use of the pointed-to
    <structname>TriggerData</> structure.  The function must
    <emphasis>not</emphasis> alter the <structname>TriggerData</>
    structure or any of the data it points to.
   </para>
____________________________________________________________________________-->
   <para>
    当一个函数被触发器管理器调用时，不会给它传递任何常规的参数，但是会有一个<quote>context</>指针传递给它，该指针指向一个<structname>TriggerData</>结构。C 函数可以通过执行一个宏来检查它们是否是从触发器管理器被调用：
<programlisting>
CALLED_AS_TRIGGER(fcinfo)
</programlisting>
    它会展开成为：
<programlisting>
((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))
</programlisting>
    如果这返回真，那么将<literal>fcinfo-&gt;context</>造型成类型<literal>TriggerData *</literal>并且利用所指向的<structname>TriggerData</>结构就是安全的。该函数<emphasis>不能</emphasis>修改该<structname>TriggerData</>结构或者它指向的任何数据。
   </para>

<!--==========================orignal english content==========================
   <para>
    <structname>struct TriggerData</structname> is defined in
    <filename>commands/trigger.h</filename>:

<programlisting>
typedef struct TriggerData
{
    NodeTag          type;
    TriggerEvent     tg_event;
    Relation         tg_relation;
    HeapTuple        tg_trigtuple;
    HeapTuple        tg_newtuple;
    Trigger         *tg_trigger;
    Buffer           tg_trigtuplebuf;
    Buffer           tg_newtuplebuf;
    Tuplestorestate *tg_oldtable;
    Tuplestorestate *tg_newtable;
} TriggerData;
</programlisting>

    where the members are defined as follows:

    <variablelist>
     <varlistentry>
      <term><structfield>type</></term>
      <listitem>
       <para>
        Always <literal>T_TriggerData</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_event</></term>
      <listitem>
       <para>
        Describes the event for which the function is called. You can use the
        following macros to examine <literal>tg_event</literal>:

        <variablelist>
         <varlistentry>
          <term><literal>TRIGGER_FIRED_BEFORE(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger fired before the operation.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_AFTER(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger fired after the operation.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_INSTEAD(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger fired instead of the operation.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_FOR_ROW(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger fired for a row-level event.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_FOR_STATEMENT(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger fired for a statement-level event.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_INSERT(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger was fired by an <command>INSERT</command> command.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_UPDATE(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger was fired by an <command>UPDATE</command> command.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_DELETE(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger was fired by a <command>DELETE</command> command.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_TRUNCATE(tg_event)</literal></term>
          <listitem>
           <para>
            Returns true if the trigger was fired by a <command>TRUNCATE</command> command.
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_relation</></term>
      <listitem>
       <para>
        A pointer to a structure describing the relation that the trigger fired for.
        Look at <filename>utils/rel.h</> for details about
        this structure.  The most interesting things are
        <literal>tg_relation-&gt;rd_att</> (descriptor of the relation
        tuples) and <literal>tg_relation-&gt;rd_rel-&gt;relname</>
        (relation name; the type is not <type>char*</> but
        <type>NameData</>; use
        <literal>SPI_getrelname(tg_relation)</> to get a <type>char*</> if you
        need a copy of the name).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigtuple</></term>
      <listitem>
       <para>
        A pointer to the row for which the trigger was fired. This is
        the row being inserted, updated, or deleted.  If this trigger
        was fired for an <command>INSERT</command> or
        <command>DELETE</command> then this is what you should return
        from the function if you don't want to replace the row with
        a different one (in the case of <command>INSERT</command>) or
        skip the operation.  For triggers on foreign tables, values of system
        columns herein are unspecified.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_newtuple</></term>
      <listitem>
       <para>
        A pointer to the new version of the row, if the trigger was
        fired for an <command>UPDATE</command>, and <symbol>NULL</> if
        it is for an <command>INSERT</command> or a
        <command>DELETE</command>. This is what you have to return
        from the function if the event is an <command>UPDATE</command>
        and you don't want to replace this row by a different one or
        skip the operation.  For triggers on foreign tables, values of system
        columns herein are unspecified.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigger</></term>
      <listitem>
       <para>
        A pointer to a structure of type <structname>Trigger</>,
        defined in <filename>utils/reltrigger.h</>:

<programlisting>
typedef struct Trigger
{
    Oid         tgoid;
    char       *tgname;
    Oid         tgfoid;
    int16       tgtype;
    char        tgenabled;
    bool        tgisinternal;
    Oid         tgconstrrelid;
    Oid         tgconstrindid;
    Oid         tgconstraint;
    bool        tgdeferrable;
    bool        tginitdeferred;
    int16       tgnargs;
    int16       tgnattr;
    int16      *tgattr;
    char      **tgargs;
    char       *tgqual;
    char       *tgoldtable;
    char       *tgnewtable;
} Trigger;
</programlisting>

       where <structfield>tgname</> is the trigger's name,
       <structfield>tgnargs</> is the number of arguments in
       <structfield>tgargs</>, and <structfield>tgargs</> is an array of
       pointers to the arguments specified in the <command>CREATE
       TRIGGER</command> statement. The other members are for internal use
       only.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigtuplebuf</></term>
      <listitem>
       <para>
        The buffer containing <structfield>tg_trigtuple</structfield>, or <symbol>InvalidBuffer</symbol> if there
        is no such tuple or it is not stored in a disk buffer.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_newtuplebuf</></term>
      <listitem>
       <para>
        The buffer containing <structfield>tg_newtuple</structfield>, or <symbol>InvalidBuffer</symbol> if there
        is no such tuple or it is not stored in a disk buffer.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_oldtable</></term>
      <listitem>
       <para>
        A pointer to a structure of type <structname>Tuplestorestate</structname>
        containing zero or more rows in the format specified by
        <structfield>tg_relation</structfield>, or a <symbol>NULL</> pointer
        if there is no <literal>OLD TABLE</literal> transition relation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_newtable</></term>
      <listitem>
       <para>
        A pointer to a structure of type <structname>Tuplestorestate</structname>
        containing zero or more rows in the format specified by
        <structfield>tg_relation</structfield>, or a <symbol>NULL</> pointer
        if there is no <literal>NEW TABLE</literal> transition relation.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <structname>struct TriggerData</structname>被定义在<filename>commands/trigger.h</filename>中：

<programlisting>
typedef struct TriggerData
{
    NodeTag          type;
    TriggerEvent     tg_event;
    Relation         tg_relation;
    HeapTuple        tg_trigtuple;
    HeapTuple        tg_newtuple;
    Trigger         *tg_trigger;
    Buffer           tg_trigtuplebuf;
    Buffer           tg_newtuplebuf;
    Tuplestorestate *tg_oldtable;
    Tuplestorestate *tg_newtable;
} TriggerData;
</programlisting>

    其中的成员被定义如下：

    <variablelist>
     <varlistentry>
      <term><structfield>type</></term>
      <listitem>
       <para>
        总是<literal>T_TriggerData</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_event</></term>
      <listitem>
       <para>
        描述该函数是为什么事件被调用的。你可以使用下列宏来检查<literal>tg_event</literal>：

        <variablelist>
         <varlistentry>
          <term><literal>TRIGGER_FIRED_BEFORE(tg_event)</literal></term>
          <listitem>
           <para>
            如果该触发器在操作前被引发则返回真。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_AFTER(tg_event)</literal></term>
          <listitem>
           <para>
            如果该触发器在操作后被引发则返回真。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_INSTEAD(tg_event)</literal></term>
          <listitem>
           <para>
            如果该触发器被引发替代操作则返回真。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_FOR_ROW(tg_event)</literal></term>
          <listitem>
           <para>
            如果该触发器为一个行级事件而引发则返回真。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_FOR_STATEMENT(tg_event)</literal></term>
          <listitem>
           <para>
            如果该触发器为一个语句级事件而引发则返回真。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_INSERT(tg_event)</literal></term>
          <listitem>
           <para>
            如果该触发器由一个<command>INSERT</command>命令引发则返回真。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_UPDATE(tg_event)</literal></term>
          <listitem>
           <para>
            如果该触发器由一个<command>UPDATE</command>命令引发则返回真。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_DELETE(tg_event)</literal></term>
          <listitem>
           <para>
            如果该触发器由一个<command>DELETE</command>命令引发则返回真。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_TRUNCATE(tg_event)</literal></term>
          <listitem>
           <para>
            如果该触发器由一个<command>TRUNCATE</command>命令引发则返回真。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_relation</></term>
      <listitem>
       <para>
        一个结构指针，该结构描述该触发器为其引发的关系。关于这个结构的细节请参考<filename>utils/rel.h</>。最有趣的东西是<literal>tg_relation-&gt;rd_att</>（该关系元组的描述符）和<literal>tg_relation-&gt;rd_rel-&gt;relname</>（关系名称，该类型不是<type>char*</>而是<type>NameData</>。如果你需要该名称的一个拷贝，可使用<literal>SPI_getrelname(tg_relation)</>来得到一个<type>char*</>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigtuple</></term>
      <listitem>
       <para>
        一个该触发器为其引发的行的指针。这是被插入、更新或删除的行。如果这个触发器是为一个<command>INSERT</command>或<command>DELETE</command>而引发，在你不想把该行替换成另一行（在<command>INSERT</command>的情况中）或不想跳过该操作时你应该从该函数中返回它。
          对于外部表上的触发器，此中的系统列值未被指定。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_newtuple</></term>
      <listitem>
       <para>
        如果该触发器为一个<command>UPDATE</command>而引发，则是一个指向该行新版本的指针。如果是为一个<command>INSERT</command>或<command>DELETE</command>而引发，则是<symbol>NULL</>。如果事件是一个<command>UPDATE</command>并且你并不想用一个不同的行替换这个行或者不想跳过该操作时，你必须从函数中返回它。对于外部表上的触发器，此中的系统列值未被指定。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigger</></term>
      <listitem>
       <para>
        一个指向类型为<structname>Trigger</>的结构的指针，定义在<filename>utils/reltrigger.h</>中：

<programlisting>
typedef struct Trigger
{
    Oid         tgoid;
    char       *tgname;
    Oid         tgfoid;
    int16       tgtype;
    char        tgenabled;
    bool        tgisinternal;
    Oid         tgconstrrelid;
    Oid         tgconstrindid;
    Oid         tgconstraint;
    bool        tgdeferrable;
    bool        tginitdeferred;
    int16       tgnargs;
    int16       tgnattr;
    int16      *tgattr;
    char      **tgargs;
    char       *tgqual;
    char       *tgoldtable;
    char       *tgnewtable;
} Trigger;
</programlisting>

       其中<structfield>tgname</>是该触发器的名称，<structfield>tgnargs</>是<structfield>tgargs</>中参数的数量，而<structfield>tgargs</>是一个指向<command>CREATE TRIGGER</command>语句中指定的参数的指针数组。其他成员只用于内部用途。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigtuplebuf</></term>
      <listitem>
       <para>
        包含<structfield>tg_trigtuple</structfield>的缓冲区。如果没有那个元组或者它没有被存储在一个磁盘缓冲区中，则为<symbol>InvalidBuffer</symbol>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_newtuplebuf</></term>
      <listitem>
       <para>
        包含<structfield>tg_newtuple</structfield>的缓冲区。如果没有那个元组或者它没有被存储在一个磁盘缓冲区中，则为<symbol>InvalidBuffer</symbol>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_oldtable</></term>
      <listitem>
       <para>
        指向<structname>Tuplestorestate</structname>类型的结构的指针，
		该指针包含由<structfield>tg_relation</structfield>指定的格式的零个或多个行，
		如果不存在<literal>OLD TABLE</literal>转换关系，则指向<symbol>NULL</>指针。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_newtable</></term>
      <listitem>
       <para>
        指向<structname>Tuplestorestate</structname>类型的结构的指针，
		该指针包含由<structfield>tg_relation</structfield>指定的格式的零个或多个行，
		如果不存在<literal>NEW TABLE</literal>转换关系，则指向<symbol>NULL</>指针。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    To allow queries issued through SPI to reference transition tables, see
    <xref linkend="spi-spi-register-trigger-data">.
   </para>
____________________________________________________________________________-->
   <para>
    要想允许通过SPI发布的查询引用转换表，请参阅
    <xref linkend="spi-spi-register-trigger-data">。
   </para>

<!--==========================orignal english content==========================
   <para>
    A trigger function must return either a
    <structname>HeapTuple</> pointer or a <symbol>NULL</> pointer
    (<emphasis>not</> an SQL null value, that is, do not set <parameter>isNull</parameter> true).
    Be careful to return either
    <structfield>tg_trigtuple</> or <structfield>tg_newtuple</>,
    as appropriate, if you don't want to modify the row being operated on.
   </para>
____________________________________________________________________________-->
   <para>
    一个触发器函数必须返回一个<structname>HeapTuple</>指针或一个<symbol>NULL</>指针（<emphasis>不是</>一个 SQL 空值，也就是不会设置<parameter>isNull</parameter>为真）。如果你不希望修改正在被操作的行，要小心地根据情况返回<structfield>tg_trigtuple</>或<structfield>tg_newtuple</>。
   </para>
  </sect1>

  <sect1 id="trigger-example">
<!--==========================orignal english content==========================
   <title>A Complete Trigger Example</title>
____________________________________________________________________________-->
   <title>一个完整的触发器实例</title>

<!--==========================orignal english content==========================
   <para>
    Here is a very simple example of a trigger function written in C.
    (Examples of triggers written in procedural languages can be found
    in the documentation of the procedural languages.)
   </para>
____________________________________________________________________________-->
   <para>
    这里有一个用 C 编写的触发器函数的非常简单的例子（用过程语言编写的触发器的例子可以在过程语言的文档中找到）。
   </para>

<!--==========================orignal english content==========================
   <para>
    The function <function>trigf</> reports the number of rows in the
    table <structname>ttest</> and skips the actual operation if the
    command attempts to insert a null value into the column
    <structfield>x</>. (So the trigger acts as a not-null constraint but
    doesn't abort the transaction.)
   </para>
____________________________________________________________________________-->
   <para>
    如果该命令试图向列<structfield>x</>中插入一个空值，函数<function>trigf</>报告表<structname>ttest</>中的行数并且跳过实际的操作（这样该触发器会作为一个非空约束但不会中止事务）。
   </para>

<!--==========================orignal english content==========================
   <para>
    First, the table definition:
<programlisting>
CREATE TABLE ttest (
    x integer
);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    首先，表定义：
<programlisting>
CREATE TABLE ttest (
    x integer
);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    This is the source code of the trigger function:
<programlisting><![CDATA[
#include "postgres.h"
#include "fmgr.h"
#include "executor/spi.h"       /* this is what you need to work with SPI */
#include "commands/trigger.h"   /* ... triggers ... */
#include "utils/rel.h"          /* ... and relations */

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(trigf);

Datum
trigf(PG_FUNCTION_ARGS)
{
    TriggerData *trigdata = (TriggerData *) fcinfo->context;
    TupleDesc   tupdesc;
    HeapTuple   rettuple;
    char       *when;
    bool        checknull = false;
    bool        isnull;
    int         ret, i;

    /* make sure it's called as a trigger at all */
    if (!CALLED_AS_TRIGGER(fcinfo))
        elog(ERROR, "trigf: not called by trigger manager");

    /* tuple to return to executor */
    if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))
        rettuple = trigdata->tg_newtuple;
    else
        rettuple = trigdata->tg_trigtuple;

    /* check for null values */
    if (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event)
        && TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        checknull = true;

    if (TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        when = "before";
    else
        when = "after ";

    tupdesc = trigdata->tg_relation->rd_att;

    /* connect to SPI manager */
    if ((ret = SPI_connect()) < 0)
        elog(ERROR, "trigf (fired %s): SPI_connect returned %d", when, ret);

    /* get number of rows in table */
    ret = SPI_exec("SELECT count(*) FROM ttest", 0);

    if (ret < 0)
        elog(ERROR, "trigf (fired %s): SPI_exec returned %d", when, ret);

    /* count(*) returns int8, so be careful to convert */
    i = DatumGetInt64(SPI_getbinval(SPI_tuptable->vals[0],
                                    SPI_tuptable->tupdesc,
                                    1,
                                    &isnull));

    elog (INFO, "trigf (fired %s): there are %d rows in ttest", when, i);

    SPI_finish();

    if (checknull)
    {
        SPI_getbinval(rettuple, tupdesc, 1, &isnull);
        if (isnull)
            rettuple = NULL;
    }

    return PointerGetDatum(rettuple);
}
]]>
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    这是该触发器函数的源代码：
<programlisting><![CDATA[
#include "postgres.h"
#include "fmgr.h"
#include "executor/spi.h"       /* this is what you need to work with SPI */
#include "commands/trigger.h"   /* ... triggers ... */
#include "utils/rel.h"          /* ... and relations */

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(trigf);

Datum
trigf(PG_FUNCTION_ARGS)
{
    TriggerData *trigdata = (TriggerData *) fcinfo->context;
    TupleDesc   tupdesc;
    HeapTuple   rettuple;
    char       *when;
    bool        checknull = false;
    bool        isnull;
    int         ret, i;

    /* make sure it's called as a trigger at all */
    if (!CALLED_AS_TRIGGER(fcinfo))
        elog(ERROR, "trigf: not called by trigger manager");

    /* tuple to return to executor */
    if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))
        rettuple = trigdata->tg_newtuple;
    else
        rettuple = trigdata->tg_trigtuple;

    /* check for null values */
    if (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event)
        && TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        checknull = true;

    if (TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        when = "before";
    else
        when = "after ";

    tupdesc = trigdata->tg_relation->rd_att;

    /* connect to SPI manager */
    if ((ret = SPI_connect()) < 0)
        elog(ERROR, "trigf (fired %s): SPI_connect returned %d", when, ret);

    /* get number of rows in table */
    ret = SPI_exec("SELECT count(*) FROM ttest", 0);

    if (ret < 0)
        elog(ERROR, "trigf (fired %s): SPI_exec returned %d", when, ret);

    /* count(*) returns int8, so be careful to convert */
    i = DatumGetInt64(SPI_getbinval(SPI_tuptable->vals[0],
                                    SPI_tuptable->tupdesc,
                                    1,
                                    &isnull));

    elog (INFO, "trigf (fired %s): there are %d rows in ttest", when, i);

    SPI_finish();

    if (checknull)
    {
        SPI_getbinval(rettuple, tupdesc, 1, &isnull);
        if (isnull)
            rettuple = NULL;
    }

    return PointerGetDatum(rettuple);
}
]]>
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    After you have compiled the source code (see <xref
    linkend="dfunc">), declare the function and the triggers:
<programlisting>
CREATE FUNCTION trigf() RETURNS trigger
    AS '<replaceable>filename</>'
    LANGUAGE C;

CREATE TRIGGER tbefore BEFORE INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE PROCEDURE trigf();

CREATE TRIGGER tafter AFTER INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE PROCEDURE trigf();
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    在你编译了该源代码（见<xref linkend="dfunc">）之后，声明该函数和触发器：
<programlisting>
CREATE FUNCTION trigf() RETURNS trigger
    AS '<replaceable>filename</>'
    LANGUAGE C;

CREATE TRIGGER tbefore BEFORE INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE PROCEDURE trigf();

CREATE TRIGGER tafter AFTER INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE PROCEDURE trigf();
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Now you can test the operation of the trigger:
<screen>
=&gt; INSERT INTO ttest VALUES (NULL);
INFO:  trigf (fired before): there are 0 rows in ttest
INSERT 0 0

-&minus; Insertion skipped and AFTER trigger is not fired

=&gt; SELECT * FROM ttest;
 x
-&minus;-
(0 rows)

=&gt; INSERT INTO ttest VALUES (1);
INFO:  trigf (fired before): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 1 rows in ttest
                                       ^^^^^^^^
                             remember what we said about visibility.
INSERT 167793 1
vac=&gt; SELECT * FROM ttest;
 x
-&minus;-
 1
(1 row)

=&gt; INSERT INTO ttest SELECT x * 2 FROM ttest;
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
                                       ^^^^^^
                             remember what we said about visibility.
INSERT 167794 1
=&gt; SELECT * FROM ttest;
 x
-&minus;-
 1
 2
(2 rows)

=&gt; UPDATE ttest SET x = NULL WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
UPDATE 0
=&gt; UPDATE ttest SET x = 4 WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
UPDATE 1
vac=&gt; SELECT * FROM ttest;
 x
-&minus;-
 1
 4
(2 rows)

=&gt; DELETE FROM ttest;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
                                       ^^^^^^
                             remember what we said about visibility.
DELETE 2
=&gt; SELECT * FROM ttest;
 x
-&minus;-
(0 rows)
</screen>

   </para>
____________________________________________________________________________-->
   <para>
    现在你可以测试该触发器的操作：
<screen>
=&gt; INSERT INTO ttest VALUES (NULL);
INFO:  trigf (fired before): there are 0 rows in ttest
INSERT 0 0

-- Insertion skipped and AFTER trigger is not fired

=&gt; SELECT * FROM ttest;
 x
---
(0 rows)

=&gt; INSERT INTO ttest VALUES (1);
INFO:  trigf (fired before): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 1 rows in ttest
                                       ^^^^^^^^
                             remember what we said about visibility.
INSERT 167793 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
(1 row)

=&gt; INSERT INTO ttest SELECT x * 2 FROM ttest;
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
                                       ^^^^^^
                             remember what we said about visibility.
INSERT 167794 1
=&gt; SELECT * FROM ttest;
 x
---
 1
 2
(2 rows)

=&gt; UPDATE ttest SET x = NULL WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
UPDATE 0
=&gt; UPDATE ttest SET x = 4 WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
UPDATE 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
 4
(2 rows)

=&gt; DELETE FROM ttest;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
                                       ^^^^^^
                             remember what we said about visibility.
DELETE 2
=&gt; SELECT * FROM ttest;
 x
---
(0 rows)
</screen>

   </para>

<!--==========================orignal english content==========================
   <para>
    There are more complex examples in
    <filename>src/test/regress/regress.c</filename> and
    in <xref linkend="contrib-spi">.
   </para>
____________________________________________________________________________-->
   <para>
    在<filename>src/test/regress/regress.c</filename>和<xref linkend="contrib-spi">中有更多复杂的例子。
   </para>
  </sect1>
 </chapter>
